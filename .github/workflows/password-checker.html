<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Password Crack-Time Estimator - A.Insiders</title>
    
    <!-- Favicon Setup -->
    <link rel="icon" type="image/png" href="ainsiders-logo.png" id="main-favicon">
    <link rel="apple-touch-icon" href="ainsiders-logo.png">
    <meta name="description" content="Advanced password strength analyzer with quantum computer simulation. Test your passwords against various attack scenarios including quantum computers, supercomputers, and more.">
    <meta name="keywords" content="password checker, password strength, quantum computer, password security, crack time estimator">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- CSS -->
    <link rel="stylesheet" href="brain-styles.css">
    <link rel="stylesheet" href="sidebar-menu.css">
    
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Favicon Animation Script -->
    <script src="favicon-animation.js"></script>
    
    <style>
        body.password-checker-page {
            background: var(--bg-primary);
            font-family: 'Inter', sans-serif;
            line-height: 1.6;
            padding-top: 80px; /* Add space for fixed navbar */
        }
        
        .password-checker-container {
            max-width: 800px;
            margin: 2rem auto;
            padding: 2rem;
            background: var(--bg-secondary);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid var(--border-color);
            position: relative;
            z-index: 1;
        }
        
        .password-checker-header {
            text-align: center;
            margin-bottom: 2rem;
        }
        
        .password-checker-header h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .password-checker-header p {
            color: var(--text-secondary);
            font-size: 1.1rem;
        }
        
        .form-group {
            margin-bottom: 1.5rem;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--text-primary);
        }
        
        .form-group input,
        .form-group select {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }
        
        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(0, 102, 255, 0.1);
        }
        
        .form-group input[type="password"] {
            font-family: 'JetBrains Mono', monospace;
        }
        
        .scenario-selector {
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .scenario-selector select {
            font-weight: 600;
            color: var(--accent-primary);
        }
        
        .divider {
            height: 1px;
            background: var(--border-color);
            margin: 2rem 0;
        }
        
        .calculate-btn {
            width: 100%;
            padding: 1rem;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-blue));
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        
        .calculate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 102, 255, 0.3);
        }
        
        .calculate-btn:active {
            transform: translateY(0);
        }
        
        .result-container {
            margin-top: 2rem;
            padding: 1.5rem;
            background: var(--bg-primary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            font-family: 'JetBrains Mono', monospace;
            white-space: pre-line;
            line-height: 1.8;
        }
        
        .result-container.error {
            background: rgba(255, 59, 48, 0.1);
            border-color: #ff3b30;
            color: #ff3b30;
        }
        
        .result-container.success {
            background: rgba(52, 199, 89, 0.1);
            border-color: #34c759;
            color: #34c759;
        }
        
        .entropy-display {
            background: linear-gradient(135deg, rgba(0, 102, 255, 0.1), rgba(52, 199, 89, 0.1));
            border: 1px solid var(--accent-primary);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
            text-align: center;
        }
        
        .entropy-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--accent-primary);
            margin-bottom: 0.5rem;
        }
        
        .entropy-label {
            color: var(--text-secondary);
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .strength-indicator {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .strength-very-weak { background: rgba(255, 59, 48, 0.2); color: #ff3b30; }
        .strength-weak { background: rgba(255, 149, 0, 0.2); color: #ff9500; }
        .strength-moderate { background: rgba(255, 204, 0, 0.2); color: #ffcc00; }
        .strength-strong { background: rgba(52, 199, 89, 0.2); color: #34c759; }
        .strength-very-strong { background: rgba(0, 102, 255, 0.2); color: var(--accent-primary); }
        .strength-extra-strong { background: rgba(138, 43, 226, 0.2); color: #8a2be2; }
        
        .live-update-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(52, 199, 89, 0.9);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            z-index: 1000;
            opacity: 0;
            transform: translateY(-20px);
            transition: all 0.3s ease;
        }
        
        .live-update-indicator.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        .info-section {
            background: rgba(0, 102, 255, 0.05);
            border: 1px solid rgba(0, 102, 255, 0.2);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .info-section h3 {
            color: var(--accent-primary);
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
        }
        
        .info-section p {
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin: 0;
        }
        
        .back-link {
            display: inline-block;
            margin-bottom: 1rem;
            color: var(--accent-primary);
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s ease;
        }
        
        .back-link:hover {
            color: var(--accent-blue);
        }
        
        .back-link i {
            margin-right: 0.5rem;
        }
        
        .checkbox-label {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
        }
        
        .checkbox-label input[type="checkbox"] {
            width: auto;
            margin-right: 0.75rem;
            cursor: pointer;
        }
        
        .checkmark {
            position: relative;
            display: inline-block;
            width: 18px;
            height: 18px;
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 4px;
            margin-right: 0.75rem;
            transition: all 0.3s ease;
        }
        
        .checkbox-label input[type="checkbox"]:checked + .checkmark {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
        }
        
        .checkbox-label input[type="checkbox"]:checked + .checkmark::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 12px;
            font-weight: bold;
        }
        
        @media (max-width: 768px) {
            .password-checker-page {
                padding-top: 60px;
            }
            
            .password-checker-container {
                margin: 1rem auto;
                padding: 1rem;
            }
            
            .password-checker-header h1 {
                font-size: 2rem;
            }
        }
        
        /* Dropdown Styles for Detailed Stats */
        .attack-analysis-dropdown,
        .hardware-specs-dropdown {
            margin: 1rem 0;
        }
        
        .attack-analysis-dropdown summary,
        .hardware-specs-dropdown summary {
            cursor: pointer;
            font-weight: bold;
            padding: 12px;
            border-radius: 6px;
            margin: 8px 0;
            transition: all 0.3s ease;
            user-select: none;
        }
        
        .attack-analysis-dropdown summary {
            color: #4CAF50;
            background: #f0f8f0;
            border: 1px solid #4CAF50;
        }
        
        .attack-analysis-dropdown summary:hover {
            background: #e8f5e8;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.2);
        }
        
        .hardware-specs-dropdown summary {
            color: #2196F3;
            background: #f0f8ff;
            border: 1px solid #2196F3;
        }
        
        .hardware-specs-dropdown summary:hover {
            background: #e3f2fd;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(33, 150, 243, 0.2);
        }
        
        .attack-analysis-dropdown div,
        .hardware-specs-dropdown div {
            padding: 16px;
            background: #f9f9f9;
            border-radius: 6px;
            margin: 8px 0;
            border-left: 4px solid;
            font-family: 'JetBrains Mono', monospace;
            line-height: 1.6;
        }
        
        .attack-analysis-dropdown div {
            border-left-color: #4CAF50;
        }
        
        .hardware-specs-dropdown div {
            border-left-color: #2196F3;
        }
        
        /* Animation for dropdown expansion */
        .attack-analysis-dropdown[open] summary,
        .hardware-specs-dropdown[open] summary {
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
        }
        
        .attack-analysis-dropdown[open] div,
        .hardware-specs-dropdown[open] div {
            border-top-left-radius: 0;
            border-top-right-radius: 0;
        }
        
        /* Info Icon Styles */
        .info-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            background: var(--accent-primary);
            color: white;
            border-radius: 50%;
            font-size: 10px;
            cursor: help;
            margin-left: 8px;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .info-icon:hover {
            background: var(--accent-blue);
            transform: scale(1.1);
        }
        
        .info-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            width: 300px;
            max-width: 90vw;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            font-size: 0.85rem;
            line-height: 1.5;
        }
        
        .info-icon:hover .info-tooltip {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(-8px);
        }
        
        .info-tooltip h4 {
            color: var(--accent-primary);
            margin: 0 0 8px 0;
            font-size: 0.9rem;
            font-weight: 600;
        }
        
        .info-tooltip p {
            color: var(--text-secondary);
            margin: 0 0 8px 0;
        }
        
        .info-tooltip ul {
            margin: 8px 0;
            padding-left: 16px;
            color: var(--text-secondary);
        }
        
        .info-tooltip li {
            margin-bottom: 4px;
        }
        
        .info-tooltip .impact {
            background: rgba(0, 102, 255, 0.1);
            border-left: 3px solid var(--accent-primary);
            padding: 8px;
            margin-top: 8px;
            border-radius: 4px;
        }
        
        .info-tooltip .impact strong {
            color: var(--accent-primary);
        }
        
        /* Form group with info icon */
        .form-group-with-info {
            position: relative;
        }
        
        .form-group-with-info label {
            display: flex;
            align-items: center;
        }
        
        /* Button styles */
        .btn {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            text-decoration: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-weight: 500;
            transition: all 0.3s ease;
            cursor: pointer;
            border: none;
        }
        
        .btn-primary {
            background: var(--accent-primary);
            color: white;
        }
        
        .btn-primary:hover {
            background: var(--accent-secondary);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 102, 255, 0.3);
        }
        
        /* Mobile responsive tooltips */
        @media (max-width: 768px) {
            .info-tooltip {
                width: 280px;
                left: 0;
                transform: translateX(0);
            }
            
            .info-icon:hover .info-tooltip {
                transform: translateX(0) translateY(-8px);
            }
        }

        /* Multi-dimensional complexity info icons */
        .complexity-info-icon {
            display: inline-block;
            margin-left: 8px;
            color: var(--accent-primary);
            cursor: help;
            font-size: 14px;
            opacity: 0.8;
            transition: opacity 0.3s ease;
        }

        .complexity-info-icon:hover {
            opacity: 1;
        }

        .complexity-tooltip {
            position: absolute;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            width: 280px;
            max-width: 90vw;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            font-size: 0.85rem;
            line-height: 1.5;
            pointer-events: none;
        }

        .complexity-info-icon:hover .complexity-tooltip {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
        }

        .complexity-tooltip h4 {
            color: var(--accent-primary);
            margin: 0 0 8px 0;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .complexity-tooltip ul {
            margin: 8px 0;
            padding-left: 16px;
            color: var(--text-secondary);
        }

        .complexity-tooltip li {
            margin-bottom: 4px;
            font-size: 0.8rem;
        }

        /* Result section styling for info icons */
        .result-section {
            position: relative;
        }

        .result-section .complexity-header {
            display: flex;
            align-items: center;
            gap: 8px;
        }
    </style>
</head>
<body class="password-checker-page">
    <!-- Navigation -->
    <nav class="navbar">
        <div class="nav-container">
            <a href="index.html" class="nav-logo">
                <img src="ainsiders-logo.png" alt="A.Insiders Logo" class="logo-image" width="40" height="40">
                <span class="logo-text">A.I</span>
                <span class="logo-accent">NSIDERS</span>
            </a>
            <ul class="nav-menu">
                <li><a href="index.html" class="nav-link">Home</a></li>
                <li><a href="apps.html" class="nav-link">Apps</a></li>
                <li><a href="tools.html" class="nav-link active">Tools</a></li>
                <li class="nav-dropdown">
                    <div class="nav-link-container">
                        <a href="about.html" class="nav-link">About</a>
                        <span class="dropdown-arrow">▼</span>
                    </div>
                    <ul class="dropdown-menu">
                        <li><a href="about.html" class="dropdown-link">About Company</a></li>
                        <li><a href="blake-zimmerman.html" class="dropdown-link">Blake Zimmerman</a></li>
                    </ul>
                </li>
                <li><a href="contact.html" class="nav-link">Contact</a></li>
            </ul>
            <div class="nav-toggle">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
    </nav>

    <!-- AI Canvas for Background Effects -->
    <canvas id="aiCanvas"></canvas>

    <div class="page-wrapper">
        <main class="main-content">
            <div class="password-checker-container">
        <a href="tools.html" class="back-link">
            <i class="fas fa-arrow-left"></i>
            Back to Tools
        </a>
        
        <div class="password-checker-header">
            <h1>🔐 Password Crack-Time Estimator</h1>
            <p>Advanced password strength analysis with quantum computer simulation</p>
            <div style="margin-top: 1rem;">
                <a href="password-generator.html" class="btn btn-primary">
                    <i class="fas fa-key"></i>
                    Generate Secure Passwords
                </a>
            </div>
        </div>
        
        <div class="info-section">
            <h3><i class="fas fa-info-circle"></i> What is this?</h3>
            <p>This tool estimates how long it would take to crack your password using different attack scenarios. It uses advanced algorithms including Grover's quantum algorithm for quantum computer attacks. <strong>Auto-updates with latest hardware benchmarks!</strong></p>
            
            <h4 style="margin-top: 1rem; margin-bottom: 0.5rem; color: var(--accent-primary);">What do I do?</h4>
            <ol style="margin: 0; padding-left: 1.5rem; color: var(--text-secondary);">
                <li>Enter your password (or leave blank and enter entropy bits directly)</li>
                <li>Choose an attack scenario (quantum computer, supercomputer, etc.)</li>
                <li>Choose hash algorithm (affects cracking speed)</li>
                <li>Click "Calculate Crack Time" to see results</li>
            </ol>
        </div>
        
        <!-- Live Entropy Display -->
        <div id="entropyDisplay" class="entropy-display" style="display: none;">
            <div class="entropy-value" id="entropyValue">0.0</div>
            <div class="entropy-label">Entropy Bits</div>
            <div id="strengthIndicator" class="strength-indicator">Enter Password</div>
        </div>
        
        <form id="passwordForm">
            <!-- Password Input -->
            <div class="form-group form-group-with-info">
                <label for="password">
                    Password
                    <div class="info-icon">
                        <i class="fas fa-question"></i>
                        <div class="info-tooltip">
                            <h4>Password Input</h4>
                            <p>Enter your password here for analysis. The tool will calculate entropy, detect patterns, and estimate crack time.</p>
                            <ul>
                                <li><strong>Entropy calculation:</strong> Automatically calculated based on character set and length</li>
                                <li><strong>Real-time analysis:</strong> See entropy and strength as you type</li>
                                <li><strong>Pattern detection:</strong> Identifies common password weaknesses</li>
                                <li><strong>Character set detection:</strong> Analyzes lowercase, uppercase, numbers, symbols</li>
                            </ul>
                            <div class="impact">
                                <strong>Impact:</strong> This is the primary input that drives all calculations. Longer, more complex passwords with diverse character sets will show higher entropy and longer crack times.
                            </div>
                        </div>
                    </div>
                </label>
                <input id="password" type="password" autocomplete="off" placeholder="Enter your password">
                <div id="passwordInfo" class="info-text" style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 0.5rem; display: none;"></div>
            </div>
            
            <!-- Password Length Display (Read-only) -->
            <div class="form-group">
                <label for="passwordLength">Password Length:</label>
                <div id="passwordLength" style="padding: 0.75rem; background-color: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-secondary); min-height: 1.2em;">Enter password above to see length</div>
            </div>
            
            <!-- Entropy Information Section -->
            <div class="form-group entropy-info-section">
                <label>Entropy Bits Information</label>
                <div class="entropy-info-content" style="padding: 1rem; background: linear-gradient(135deg, rgba(0, 102, 255, 0.1), rgba(138, 43, 226, 0.1)); border: 1px solid var(--border-color); border-radius: 8px; margin-top: 0.5rem;">
                    <h4 style="margin: 0 0 0.5rem 0; color: var(--accent-primary);">What are Entropy Bits?</h4>
                    <p style="margin: 0 0 0.5rem 0; font-size: 0.9rem; color: var(--text-secondary);">
                        Entropy bits measure the randomness and unpredictability of your password. Higher entropy means the password is harder to guess or crack.
                    </p>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-top: 0.5rem;">
                        <div>
                            <strong style="color: var(--accent-primary);">Character Set Impact:</strong>
                            <ul style="margin: 0.25rem 0; padding-left: 1.2rem; font-size: 0.85rem; color: var(--text-secondary);">
                                <li>Lowercase (a-z): ~4.7 bits per character</li>
                                <li>Uppercase (A-Z): ~4.7 bits per character</li>
                                <li>Numbers (0-9): ~3.3 bits per character</li>
                                <li>Symbols (!@#$%): ~5.9 bits per character</li>
                            </ul>
                        </div>
                        <div>
                            <strong style="color: var(--accent-primary);">Security Levels:</strong>
                            <ul style="margin: 0.25rem 0; padding-left: 1.2rem; font-size: 0.85rem; color: var(--text-secondary);">
                                <li>0-19 score: Very Weak (easily cracked)</li>
                                <li>20-39 score: Weak (minutes to hours)</li>
                                <li>40-59 score: Moderate (hours to days)</li>
                                <li>60-79 score: Strong (days to weeks)</li>
                                <li>80-99 score: Excellent (weeks to months)</li>
                                <li>50+ chars: Moderate (length-based)</li>
                                <li>128+ chars: Strong (length-based)</li>
                                <li>520+ chars: Extra Strong (length-based)</li>
                            </ul>
                        </div>
                    </div>
                    <div style="margin-top: 0.5rem; padding: 0.5rem; background: rgba(0, 102, 255, 0.05); border-radius: 4px; font-size: 0.85rem; color: var(--text-secondary);">
                        <strong>Formula:</strong> Entropy = log₂(character_set_size^password_length) - pattern_penalties + complexity_bonuses
                    </div>
                </div>
            </div>
            
            <!-- Hash Algorithm -->
            <div class="form-group form-group-with-info">
                <label for="hash">
                    Hash Algorithm
                    <div class="info-icon">
                        <i class="fas fa-question"></i>
                        <div class="info-tooltip">
                            <h4>Hash Algorithm</h4>
                            <p>The cryptographic hash function used to store your password. Different algorithms have vastly different cracking speeds.</p>
                            <ul>
                                <li><strong>MD5:</strong> Very fast to crack (deprecated)</li>
                                <li><strong>SHA256:</strong> Standard, moderately fast</li>
                                <li><strong>bcrypt:</strong> Slow, designed for passwords</li>
                                <li><strong>Argon2:</strong> Slowest, most secure</li>
                            </ul>
                            <div class="impact">
                                <strong>Impact:</strong> This dramatically affects crack time. Argon2 can make a password 100,000x harder to crack than MD5 for the same password.
                            </div>
                        </div>
                    </div>
                </label>
                <select id="hash" onchange="updateHashInfo()">
                    <option value="MD5" data-s0="1.3e13">MD5 (fastest)</option>
                    <option value="SHA256" data-s0="9.0e11">SHA256</option>
                    <option value="bcrypt" data-s0="7.0e8">bcrypt (slow)</option>
                    <option value="argon2" data-s0="8.0e4">Argon2 (slowest)</option>
                </select>
                <div id="hashInfo" class="info-text" style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 0.5rem; display: none;"></div>
            </div>
            
            <!-- AI Penalty -->
            <div class="form-group form-group-with-info">
                <label class="checkbox-label">
                    <input type="checkbox" id="hum" data-penalty="10">
                    <span class="checkmark"></span>
                    Apply AI guessing penalty (reduces entropy by 10 bits)
                    <div class="info-icon">
                        <i class="fas fa-question"></i>
                        <div class="info-tooltip">
                            <h4>AI Guessing Penalty</h4>
                            <p>Modern AI systems can predict password patterns better than traditional brute force attacks.</p>
                            <ul>
                                <li><strong>Pattern recognition:</strong> AI can identify common password structures</li>
                                <li><strong>Context awareness:</strong> Uses personal info to guess passwords</li>
                                <li><strong>Learning algorithms:</strong> Improves over time with more data</li>
                            </ul>
                            <div class="impact">
                                <strong>Impact:</strong> Reduces effective entropy by 10 bits, making passwords ~1000x easier to crack by AI systems compared to random guessing.
                            </div>
                        </div>
                    </div>
                </label>
            </div>
            
            <!-- Additional Options -->
            <div class="form-group form-group-with-info">
                <label class="checkbox-label">
                    <input type="checkbox" id="showDetailed" checked>
                    <span class="checkmark"></span>
                    Show detailed technical breakdown
                    <div class="info-icon">
                        <i class="fas fa-question"></i>
                        <div class="info-tooltip">
                            <h4>Detailed Technical Breakdown</h4>
                            <p>Shows comprehensive analysis including attack vectors, hardware specifications, and vulnerability assessments.</p>
                            <ul>
                                <li><strong>Attack vectors:</strong> Lists all possible attack methods</li>
                                <li><strong>Hardware specs:</strong> Detailed device capabilities</li>
                                <li><strong>Vulnerability analysis:</strong> Quantum, neural, and adaptive assessments</li>
                                <li><strong>Timing differences:</strong> Impact of each feature</li>
                            </ul>
                            <div class="impact">
                                <strong>Impact:</strong> Provides deeper insights into password security but may increase calculation time and output complexity.
                            </div>
                        </div>
                    </div>
                </label>
            </div>
            

            
            <!-- Advanced Attack Vector Options -->
            <div class="form-group form-group-with-info">
                <label class="checkbox-label">
                    <input type="checkbox" id="enableMultiVector" checked>
                    <span class="checkmark"></span>
                    Enable multi-vector attack simulation
                    <div class="info-icon">
                        <i class="fas fa-question"></i>
                        <div class="info-tooltip">
                            <h4>Multi-Vector Attack Simulation</h4>
                            <p>Simulates attackers using multiple attack methods simultaneously for more realistic crack time estimates.</p>
                            <ul>
                                <li><strong>Parallel attacks:</strong> Brute force + dictionary + pattern matching</li>
                                <li><strong>Resource optimization:</strong> Allocates computing power across methods</li>
                                <li><strong>Realistic modeling:</strong> Mimics actual attacker behavior</li>
                            </ul>
                            <div class="impact">
                                <strong>Impact:</strong> Typically reduces crack time by 20-50% compared to single-vector attacks, as attackers can try multiple methods simultaneously.
                            </div>
                        </div>
                    </div>
                </label>
            </div>
            
            <div class="form-group form-group-with-info">
                <label class="checkbox-label">
                    <input type="checkbox" id="enablePatternAnalysis" checked>
                    <span class="checkmark"></span>
                    Enable advanced pattern analysis
                    <div class="info-icon">
                        <i class="fas fa-question"></i>
                        <div class="info-tooltip">
                            <h4>Advanced Pattern Analysis</h4>
                            <p>Detects common password patterns that make them easier to crack than pure entropy suggests.</p>
                            <ul>
                                <li><strong>Sequential patterns:</strong> "12345", "qwerty", "abcde"</li>
                                <li><strong>Repeated characters:</strong> "aaa", "111", "zzz"</li>
                                <li><strong>Keyboard walks:</strong> "qwerty", "asdfgh"</li>
                                <li><strong>Dictionary words:</strong> Common words and variations</li>
                            </ul>
                            <div class="impact">
                                <strong>Impact:</strong> Can reduce effective entropy by 5-15 bits for passwords with obvious patterns, making them significantly easier to crack.
                            </div>
                        </div>
                    </div>
                </label>
            </div>
            
            <div class="form-group form-group-with-info">
                <label class="checkbox-label">
                    <input type="checkbox" id="enableQuantumAttacks" checked>
                    <span class="checkmark"></span>
                    Enable quantum attack vectors
                    <div class="info-icon">
                        <i class="fas fa-question"></i>
                        <div class="info-tooltip">
                            <h4>Quantum Attack Vectors</h4>
                            <p>Simulates attacks using quantum computers with Grover's algorithm and other quantum techniques.</p>
                            <ul>
                                <li><strong>Grover's algorithm:</strong> Reduces search space by square root</li>
                                <li><strong>Quantum annealing:</strong> Optimizes attack strategies</li>
                                <li><strong>Quantum parallelism:</strong> Simultaneous evaluation of multiple possibilities</li>
                            </ul>
                            <div class="impact">
                                <strong>Impact:</strong> Quantum computers can crack passwords exponentially faster. A 128-bit password becomes effectively 64-bit against quantum attacks.
                            </div>
                        </div>
                    </div>
                </label>
            </div>
            
            <div class="form-group form-group-with-info">
                <label class="checkbox-label">
                    <input type="checkbox" id="enableSocialEngineering" checked>
                    <span class="checkmark"></span>
                    Enable social engineering factors
                    <div class="info-icon">
                        <i class="fas fa-question"></i>
                        <div class="info-tooltip">
                            <h4>Social Engineering Factors</h4>
                            <p>Accounts for how personal information can be used to guess passwords more effectively.</p>
                            <ul>
                                <li><strong>Personal data:</strong> Names, birthdays, addresses</li>
                                <li><strong>Common substitutions:</strong> "3" for "e", "@" for "a"</li>
                                <li><strong>Behavioral patterns:</strong> How people create passwords</li>
                                <li><strong>Context awareness:</strong> Site-specific patterns</li>
                            </ul>
                            <div class="impact">
                                <strong>Impact:</strong> Can reduce entropy by 3-8 bits by prioritizing likely password variations based on personal information and common patterns.
                            </div>
                        </div>
                    </div>
                </label>
            </div>
            

            
            <!-- Attack Scenario Selection -->
            <div class="form-group scenario-selector form-group-with-info">
                <label for="scenario">
                    Attack Scenario
                    <div class="info-icon">
                        <i class="fas fa-question"></i>
                        <div class="info-tooltip">
                            <h4>Attack Scenario</h4>
                            <p>Choose the type of hardware that would be used to crack your password. Different scenarios have vastly different computational power.</p>
                            <ul>
                                <li><strong>Quantum computer:</strong> Uses Grover's algorithm for exponential speedup</li>
                                <li><strong>Super-computer:</strong> High-performance computing cluster</li>
                                <li><strong>Modern workstation:</strong> High-end desktop with multiple GPUs</li>
                                <li><strong>USB password cracker:</strong> Specialized hardware device</li>
                            </ul>
                            <div class="impact">
                                <strong>Impact:</strong> This is the most important factor affecting crack time. Quantum computers can be millions of times faster than traditional hardware.
                            </div>
                        </div>
                    </div>
                </label>
                <select id="scenario" onchange="setDefaults()">
                    <option value="quantum">Quantum computer (Grover's algorithm)</option>
                    <option value="super">Super-computer</option>
                    <option value="workstation">Modern workstation</option>
                    <option value="usb">USB password cracker</option>
                </select>
            </div>
            
                         <!-- Hardware Configuration -->
             <div class="form-group form-group-with-info">
                 <label for="deviceCount">
                     Number of devices/units
                     <div class="info-icon">
                         <i class="fas fa-question"></i>
                         <div class="info-tooltip">
                             <h4>Number of Devices/Units</h4>
                             <p>Specify how many identical computing devices will be used simultaneously for password cracking.</p>
                             <ul>
                                 <li><strong>GPU clusters:</strong> Multiple graphics cards</li>
                                 <li><strong>Server farms:</strong> Multiple computers</li>
                                 <li><strong>Quantum processors:</strong> Multiple quantum computers</li>
                                 <li><strong>Distributed systems:</strong> Network of devices</li>
                             </ul>
                             <div class="impact">
                                 <strong>Impact:</strong> More devices = faster cracking. 4 devices can crack passwords ~4x faster than 1 device (with perfect scaling).
                             </div>
                         </div>
                     </div>
                 </label>
                 <input id="deviceCount" type="number" value="1" min="1" max="10000" placeholder="Enter number of devices">
                 <div class="info-text" style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 0.5rem;">
                     How many identical devices to use in parallel (e.g., 4 GPUs, 8 servers)
                 </div>
             </div>
             
             <div class="form-group form-group-with-info">
                 <label for="coreCount">
                     Number of cores per device
                     <div class="info-icon">
                         <i class="fas fa-question"></i>
                         <div class="info-tooltip">
                             <h4>Number of Cores per Device</h4>
                             <p>Specify the computational cores available on each device for parallel processing.</p>
                             <ul>
                                 <li><strong>CPU cores:</strong> Traditional processor cores</li>
                                 <li><strong>GPU cores:</strong> Graphics processing units</li>
                                 <li><strong>Quantum qubits:</strong> Quantum bits for quantum computers</li>
                                 <li><strong>ASIC cores:</strong> Specialized hardware</li>
                             </ul>
                             <div class="impact">
                                 <strong>Impact:</strong> More cores = faster processing. A 64-core GPU can process 64 password attempts simultaneously.
                             </div>
                         </div>
                     </div>
                 </label>
                 <input id="coreCount" type="number" value="1" min="1" max="10000" placeholder="Enter number of cores">
                 <div class="info-text" style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 0.5rem;">
                     CPU cores, GPU cores, or quantum qubits per device
                 </div>
             </div>
             
             <div class="form-group form-group-with-info">
                 <label for="parallelEfficiency">
                     Parallel efficiency (%)
                     <div class="info-icon">
                         <i class="fas fa-question"></i>
                         <div class="info-tooltip">
                             <h4>Parallel Efficiency</h4>
                             <p>How efficiently multiple cores and devices work together. Perfect scaling is rarely achieved in practice.</p>
                             <ul>
                                 <li><strong>100%:</strong> Perfect scaling (rare in practice)</li>
                                 <li><strong>80-95%:</strong> Good scaling (typical for well-optimized systems)</li>
                                 <li><strong>50-80%:</strong> Moderate scaling (communication overhead)</li>
                                 <li><strong>Below 50%:</strong> Poor scaling (bottlenecks)</li>
                             </ul>
                             <div class="impact">
                                 <strong>Impact:</strong> Lower efficiency means diminishing returns. 4 devices at 50% efficiency only provide ~2x speedup instead of 4x.
                             </div>
                         </div>
                     </div>
                 </label>
                 <input id="parallelEfficiency" type="number" value="100" min="1" max="100" step="1" placeholder="Enter efficiency percentage">
                 <div class="info-text" style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 0.5rem;">
                     How efficiently parallel processing scales (100% = perfect scaling)
                 </div>
             </div>
             
             <!-- Advanced Settings -->
             <div class="form-group form-group-with-info">
                 <label for="s0">
                     Current speed S₀ (<span id="unit">oracle calls</span>/sec)
                     <div class="info-icon">
                         <i class="fas fa-question"></i>
                         <div class="info-tooltip">
                             <h4>Current Speed (S₀)</h4>
                             <p>The number of password attempts that can be tested per second with current hardware.</p>
                             <ul>
                                 <li><strong>Oracle calls:</strong> Password verification attempts</li>
                                 <li><strong>Hash operations:</strong> Cryptographic function evaluations</li>
                                 <li><strong>Hardware dependent:</strong> Varies by device type</li>
                                 <li><strong>Auto-populated:</strong> Based on selected scenario</li>
                             </ul>
                             <div class="impact">
                                 <strong>Impact:</strong> Higher speed = faster cracking. This is the base rate that gets multiplied by hardware improvements over time.
                             </div>
                         </div>
                     </div>
                 </label>
                 <input id="s0" type="number" placeholder="Enter current speed">
             </div>
             
             <div class="form-group form-group-with-info">
                 <label for="tdbl">
                     Hardware doubling period T<sub>dbl</sub> (years)
                     <div class="info-icon">
                         <i class="fas fa-question"></i>
                         <div class="info-tooltip">
                             <h4>Hardware Doubling Period (T<sub>dbl</sub>)</h4>
                             <p>How long it takes for computing power to double (Moore's Law equivalent).</p>
                             <ul>
                                 <li><strong>Traditional hardware:</strong> ~1.5-2 years</li>
                                 <li><strong>Quantum computers:</strong> ~1 year (rapid development)</li>
                                 <li><strong>Specialized ASICs:</strong> ~2-3 years</li>
                                 <li><strong>GPU improvements:</strong> ~1.5 years</li>
                             </ul>
                             <div class="impact">
                                 <strong>Impact:</strong> Shorter doubling periods mean hardware gets faster quickly, reducing crack times for future projections.
                             </div>
                         </div>
                     </div>
                 </label>
                 <input id="tdbl" type="number" step="0.1" placeholder="Enter doubling period">
             </div>
             
             <div class="form-group form-group-with-info">
                 <label for="t">
                     Years in the future to project (t)
                     <div class="info-icon">
                         <i class="fas fa-question"></i>
                         <div class="info-tooltip">
                             <h4>Future Projection Years (t)</h4>
                             <p>How many years into the future to calculate crack time, accounting for hardware improvements.</p>
                             <ul>
                                 <li><strong>0 years:</strong> Current hardware only</li>
                                 <li><strong>1-5 years:</strong> Near-term improvements</li>
                                 <li><strong>5-10 years:</strong> Medium-term projections</li>
                                 <li><strong>10+ years:</strong> Long-term estimates</li>
                             </ul>
                             <div class="impact">
                                 <strong>Impact:</strong> Longer projections show faster crack times due to improved hardware. Useful for long-term password security planning.
                             </div>
                         </div>
                     </div>
                 </label>
                 <input id="t" type="number" value="0" step="0.1" placeholder="Enter projection years">
             </div>
            
                         <button type="button" onclick="estimateOmnidimensional()" class="calculate-btn">
                <i class="fas fa-calculator"></i>
                Calculate Crack Time
            </button>
        </form>
        
        <div id="result" class="result-container" style="display: none;"></div>
            </div>
        </main>

        <!-- Footer -->
        <footer class="footer">
            <div class="container">
                <div class="footer-content">
                    <div class="footer-section">
                        <h4>Quick Links</h4>
                        <ul>
                            <li><a href="index.html">Home</a></li>
                            <li><a href="about.html">About</a></li>
                            <li><a href="software.html">Software</a></li>
                            <li><a href="contact.html">Contact</a></li>
                        </ul>
                    </div>
                    <div class="footer-section">
                        <h4>Connect With Us</h4>
                        <div class="social-links">
                            <a href="https://www.linkedin.com/in/blake-zimmerman-a59575342/" class="social-link" title="LinkedIn" target="_blank" rel="noopener">
                                <i class="fab fa-linkedin"></i>
                                <span>LinkedIn</span>
                            </a>
                            <a href="https://github.com/AInsiders" class="social-link" title="GitHub" target="_blank" rel="noopener">
                                <i class="fab fa-github"></i>
                                <span>GitHub</span>
                            </a>
                            <a href="https://www.youtube.com/@A.Insiders01" class="social-link" title="YouTube" target="_blank" rel="noopener">
                                <i class="fab fa-youtube"></i>
                                <span>YouTube</span>
                            </a>
                            <a href="https://discord.gg/Y4kCtaBZFM" class="social-link" title="Discord" target="_blank" rel="noopener">
                                <i class="fab fa-discord"></i>
                                <span>Discord</span>
                            </a>
                        </div>
                    </div>
                </div>
                <div class="footer-bottom">
                    <p>&copy; 2024 A.Insiders Network. All rights reserved.</p>
                    <div class="footer-links">
                        <a href="privacy-policy.html">Privacy Policy</a>
                        <a href="terms-of-service.html">Terms of Service</a>
                        <a href="cookie-policy.html">Cookie Policy</a>
                    </div>
                </div>
            </div>
        </footer>
    </div>
    
    <!-- Live Update Indicator -->
    <div id="liveUpdateIndicator" class="live-update-indicator">
        <i class="fas fa-sync-alt"></i> Live Updates Active
    </div>
    
    <!-- Revolutionary Password Cracking Algorithm Script -->
    <script>
        // REVOLUTIONARY OMNIDIMENSIONAL PASSWORD CRACKING ALGORITHM v3.0
        // "The Omni-Algorithm" - Calculates Everything
        
        // Advanced Password Cracking Algorithm v2.0
        // Based on real-world research and multi-vector attack modeling
        
        // Auto-update system for live benchmarks
        const remoteURL = "pw-crack-speeds.json"; // Local file for now, can be changed to remote URL
        
        async function pullLiveDefaults() {
            try {
                const res = await fetch(remoteURL, {cache: "no-store"});
                if (!res.ok) throw new Error(res.status);
                const j = await res.json();

                // 1️⃣ scenario speeds
                for (const s in j.scenarios) {
                    if (!defaults[s]) continue;
                    defaults[s].s0   = j.scenarios[s].S0   ?? defaults[s].s0;
                    defaults[s].tdbl = j.scenarios[s].Tdbl ?? defaults[s].tdbl;
                    if (s === "quantum" && j.scenarios[s].qeff)
                        defaults[s].qeff = j.scenarios[s].qeff;      // add new field
                }

                // 2️⃣ per-hash speeds
                const hashSel = document.getElementById("hash");
                if (hashSel) {
                    [...hashSel.options].forEach(o=>{
                        const sp = j.hashes[o.value];
                        if (sp) o.dataset.s0 = sp;                     // overwrite <option data-s0>
                    });
                }

                // 3️⃣ AI-entropy penalty
                if (j.ai_penalty_bits) {
                    const humBox = document.getElementById("hum");
                    if (humBox) humBox.dataset.penalty = j.ai_penalty_bits;
                }

                console.log("🔄 Defaults refreshed from remote:", j.updated);
                setDefaults();           // refresh the form with new numbers
            } catch (e) {
                console.warn("⚠️  Live-update failed, using baked-in numbers:", e);
            }
        }

        const defaults = {
            quantum     : {s0: 1e9,  tdbl: 1.5, unit: 'oracle calls'},
            super       : {s0: 1e12, tdbl: 1.5, unit: 'tests'},
            workstation : {s0: 1e10, tdbl: 2,   unit: 'tests'},
            usb         : {s0: 1e7,  tdbl: 3,   unit: 'tests'}
        };
        
        function setDefaults() {
            const s = document.getElementById('scenario').value;
            const hardware = HARDWARE_BENCHMARKS[s];
            
            // Set basic defaults
            document.getElementById('s0').value = defaults[s].s0;
            document.getElementById('tdbl').value = defaults[s].tdbl;
            document.getElementById('unit').textContent = defaults[s].unit;
            
            // Set hardware configuration defaults
            document.getElementById('deviceCount').value = hardware.default_devices;
            document.getElementById('coreCount').value = hardware.default_cores;
            document.getElementById('parallelEfficiency').value = hardware.default_efficiency;
        }
        
        // REVOLUTIONARY OMNIDIMENSIONAL ALGORITHM CONSTANTS
        const QUANTUM_ANNEALING_FACTORS = {
            temperature_decay: 0.95,
            quantum_tunneling: 0.3,
            classical_optimization: 0.7,
            hybrid_quantum_classical: 0.5
        };
        
        const NEURAL_PATTERN_WEIGHTS = {
            sequential_penalty: 0.15,
            repeated_penalty: 0.12,
            keyboard_walk_penalty: 0.18,
            dictionary_penalty: 0.25,
            predictable_penalty: 0.20,
            ai_guessing_penalty: 0.30,
            social_engineering_penalty: 0.22
        };
        
        const MULTI_DIMENSIONAL_ENTROPY_FACTORS = {
            spatial_complexity: 1.2,
            temporal_complexity: 1.1,
            semantic_complexity: 1.3,
            contextual_complexity: 1.15,
            behavioral_complexity: 1.25
        };
        
        // Real-world hardware benchmarks (updated 2025)
        const HARDWARE_BENCHMARKS = {
            // USB Devices (portable cracking)
            usb: {
                base_speed: 5e10, // 50 billion hashes/sec (single GPU)
                default_devices: 1,
                default_cores: 1,
                default_efficiency: 100,
                parallel_factor: 1,
                cost_factor: 1,
                availability: 1.0,
                attack_vectors: ['brute_force', 'dictionary', 'hybrid'],
                quantum_capability: 0.0,
                neural_network_capability: 0.1,
                adaptive_learning: 0.05
            },
            
            // Modern Workstations (8x RTX 4090)
            workstation: {
                base_speed: 1.6e12, // 1.6 trillion hashes/sec
                default_devices: 8,
                default_cores: 1,
                default_efficiency: 85,
                parallel_factor: 8,
                cost_factor: 10,
                availability: 0.8,
                attack_vectors: ['brute_force', 'dictionary', 'hybrid', 'rainbow_table', 'mask_attack'],
                quantum_capability: 0.0,
                neural_network_capability: 0.8,
                adaptive_learning: 0.6
            },
            
            // Supercomputers (thousands of GPUs)
            super: {
                base_speed: 2e14, // 200 trillion hashes/sec
                default_devices: 1000,
                default_cores: 1,
                default_efficiency: 70,
                parallel_factor: 1000,
                cost_factor: 1000,
                availability: 0.1,
                attack_vectors: ['brute_force', 'dictionary', 'hybrid', 'rainbow_table', 'mask_attack', 'distributed'],
                quantum_capability: 0.1,
                neural_network_capability: 0.95,
                adaptive_learning: 0.9
            },
            
            // Quantum Computers (Grover's algorithm + hybrid attacks)
            quantum: {
                base_speed: 1e15, // 1 quadrillion oracle calls/sec (theoretical)
                default_devices: 10000,
                default_cores: 1,
                default_efficiency: 50,
                parallel_factor: 10000,
                cost_factor: 100000,
                availability: 0.01,
                attack_vectors: ['grover_quantum', 'hybrid_quantum', 'multi_algorithm', 'quantum_dictionary', 'quantum_annealing'],
                quantum_capability: 1.0,
                neural_network_capability: 0.9,
                adaptive_learning: 0.95
            }
        };
        
        // Hash algorithm performance multipliers
        const HASH_MULTIPLIERS = {
            'MD5': 1.0,
            'SHA1': 0.8,
            'SHA256': 0.6,
            'SHA512': 0.4,
            'bcrypt': 0.01,
            'scrypt': 0.005,
            'Argon2': 0.002,
            'PBKDF2': 0.1
        };
        
        // Attack vector multipliers (revolutionary multi-dimensional approach)
        const ATTACK_VECTOR_MULTIPLIERS = {
            'brute_force': 1.0,
            'dictionary': 0.001,
            'hybrid': 0.01,
            'rainbow_table': 0.0001,
            'mask_attack': 0.1,
            'distributed': 0.8,
            'grover_quantum': 0.5,
            'hybrid_quantum': 0.3,
            'multi_algorithm': 0.2,
            'quantum_dictionary': 0.05,
            'quantum_annealing': 0.4,
            'neural_network': 0.15,
            'adaptive_learning': 0.25,
            'multi_dimensional': 0.35
        };
        
        // REVOLUTIONARY OMNIDIMENSIONAL PATTERN ANALYSIS
        function analyzeOmnidimensionalPatterns(password) {
            const patterns = {
                sequential: 0,
                repeated: 0,
                keyboard_walk: 0,
                dictionary_based: 0,
                predictable: 0,
                spatial_complexity: 0,
                temporal_complexity: 0,
                semantic_complexity: 0,
                contextual_complexity: 0,
                behavioral_complexity: 0,
                quantum_vulnerability: 0,
                neural_vulnerability: 0,
                adaptive_vulnerability: 0,
                entropy_reduction: 0
            };
            
            // Classical pattern detection
            for (let i = 0; i < password.length - 1; i++) {
                const current = password.charCodeAt(i);
                const next = password.charCodeAt(i + 1);
                
                // Sequential patterns (123, abc, etc.)
                if (next === current + 1) {
                    patterns.sequential++;
                }
                
                // Repeated characters
                if (next === current) {
                    patterns.repeated++;
                }
            }
            
            // Keyboard walk detection (qwerty, asdf, etc.)
            const keyboard_patterns = ['qwerty', 'asdf', 'zxcv', '123456', 'abcdef'];
            for (const pattern of keyboard_patterns) {
                if (password.toLowerCase().includes(pattern)) {
                    patterns.keyboard_walk += pattern.length;
                }
            }
            
            // Dictionary-based detection
            const common_words = ['password', 'admin', 'user', 'login', 'welcome', 'hello', 'test'];
            for (const word of common_words) {
                if (password.toLowerCase().includes(word)) {
                    patterns.dictionary_based += word.length;
                }
            }
            
            // Predictable patterns (dates, years, names)
            const year_pattern = /\b(19|20)\d{2}\b/;
            const date_pattern = /\b(0?[1-9]|[12]\d|3[01])[\/\-](0?[1-9]|1[012])[\/\-](19|20)\d{2}\b/;
            if (year_pattern.test(password) || date_pattern.test(password)) {
                patterns.predictable += 4;
            }
            
            // REVOLUTIONARY: Multi-dimensional complexity analysis
            patterns.spatial_complexity = calculateSpatialComplexity(password);
            patterns.temporal_complexity = calculateTemporalComplexity(password);
            patterns.semantic_complexity = calculateSemanticComplexity(password);
            patterns.contextual_complexity = calculateContextualComplexity(password);
            patterns.behavioral_complexity = calculateBehavioralComplexity(password);
            
            // REVOLUTIONARY: Quantum vulnerability assessment
            patterns.quantum_vulnerability = calculateQuantumVulnerability(password);
            patterns.neural_vulnerability = calculateNeuralVulnerability(password);
            patterns.adaptive_vulnerability = calculateAdaptiveVulnerability(password);
            
            // Calculate total entropy reduction using neural weights
            patterns.entropy_reduction = (
                patterns.sequential * NEURAL_PATTERN_WEIGHTS.sequential_penalty +
                patterns.repeated * NEURAL_PATTERN_WEIGHTS.repeated_penalty +
                patterns.keyboard_walk * NEURAL_PATTERN_WEIGHTS.keyboard_walk_penalty +
                patterns.dictionary_based * NEURAL_PATTERN_WEIGHTS.dictionary_penalty +
                patterns.predictable * NEURAL_PATTERN_WEIGHTS.predictable_penalty
            );
            
            return patterns;
        }
        
        // REVOLUTIONARY: Multi-dimensional complexity calculations
        function calculateSpatialComplexity(password) {
            // Analyze spatial distribution of characters
            const char_positions = {};
            for (let i = 0; i < password.length; i++) {
                const char = password[i];
                if (!char_positions[char]) char_positions[char] = [];
                char_positions[char].push(i);
            }
            
            let spatial_score = 0;
            for (const char in char_positions) {
                const positions = char_positions[char];
                if (positions.length > 1) {
                    // Calculate clustering factor
                    const avg_distance = positions.reduce((sum, pos, idx) => {
                        if (idx === 0) return 0;
                        return sum + Math.abs(pos - positions[idx - 1]);
                    }, 0) / (positions.length - 1);
                    spatial_score += avg_distance / password.length;
                }
            }
            
            return Math.min(1.0, spatial_score);
        }
        
        function calculateTemporalComplexity(password) {
            // Analyze temporal patterns (typing speed, rhythm)
            const char_frequency = {};
            for (const char of password) {
                char_frequency[char] = (char_frequency[char] || 0) + 1;
            }
            
            const frequencies = Object.values(char_frequency);
            const avg_freq = frequencies.reduce((a, b) => a + b, 0) / frequencies.length;
            const variance = frequencies.reduce((sum, freq) => sum + Math.pow(freq - avg_freq, 2), 0) / frequencies.length;
            
            return Math.min(1.0, variance / (avg_freq * avg_freq));
        }
        
        function calculateSemanticComplexity(password) {
            // Analyze semantic meaning and context
            const has_meaningful_words = /(password|admin|user|login|welcome|hello|test|name|email|phone)/i.test(password);
            const has_numbers = /\d/.test(password);
            const has_symbols = /[^A-Za-z0-9]/.test(password);
            
            let semantic_score = 0;
            if (!has_meaningful_words) semantic_score += 0.4;
            if (has_numbers) semantic_score += 0.3;
            if (has_symbols) semantic_score += 0.3;
            
            return semantic_score;
        }
        
        function calculateContextualComplexity(password) {
            // Analyze context-based patterns (personal info, cultural references)
            const personal_patterns = [
                /\b(19|20)\d{2}\b/, // Years
                /\b(0?[1-9]|[12]\d|3[01])\b/, // Days
                /\b(0?[1-9]|1[012])\b/, // Months
                /\b(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\b/i, // Month names
                /\b(sun|mon|tue|wed|thu|fri|sat)\b/i // Day names
            ];
            
            let contextual_score = 1.0;
            for (const pattern of personal_patterns) {
                if (pattern.test(password)) {
                    contextual_score -= 0.2;
                }
            }
            
            return Math.max(0.0, contextual_score);
        }
        
        function calculateBehavioralComplexity(password) {
            // Analyze behavioral patterns (typing habits, cognitive load)
            const has_mixed_case = /[a-z]/.test(password) && /[A-Z]/.test(password);
            const has_alternating_patterns = /([a-z][A-Z]|[A-Z][a-z])/.test(password);
            const has_random_distribution = calculateRandomnessScore(password);
            
            let behavioral_score = 0;
            if (has_mixed_case) behavioral_score += 0.3;
            if (has_alternating_patterns) behavioral_score += 0.2;
            behavioral_score += has_random_distribution * 0.5;
            
            return Math.min(1.0, behavioral_score);
        }
        
        function calculateRandomnessScore(password) {
            // Calculate how random the password appears
            const char_freq = {};
            for (const char of password) {
                char_freq[char] = (char_freq[char] || 0) + 1;
            }
            
            const frequencies = Object.values(char_freq);
            const expected_freq = password.length / Object.keys(char_freq).length;
            const chi_square = frequencies.reduce((sum, freq) => sum + Math.pow(freq - expected_freq, 2) / expected_freq, 0);
            
            // Convert to randomness score (0-1)
            return Math.max(0, 1 - (chi_square / password.length));
        }
        
        // REVOLUTIONARY: Quantum vulnerability assessment
        function calculateQuantumVulnerability(password) {
            // Use basic pattern detection to avoid recursion
            let sequential = 0, repeated = 0, keyboard_walk = 0, dictionary_based = 0, predictable = 0;
            
            // Basic pattern detection
            for (let i = 0; i < password.length - 1; i++) {
                const current = password.charCodeAt(i);
                const next = password.charCodeAt(i + 1);
                
                if (next === current + 1) sequential++;
                if (next === current) repeated++;
            }
            
            const keyboard_patterns = ['qwerty', 'asdf', 'zxcv', '123456', 'abcdef'];
            for (const pattern of keyboard_patterns) {
                if (password.toLowerCase().includes(pattern)) {
                    keyboard_walk += pattern.length;
                }
            }
            
            const common_words = ['password', 'admin', 'user', 'login', 'welcome', 'hello', 'test'];
            for (const word of common_words) {
                if (password.toLowerCase().includes(word)) {
                    dictionary_based += word.length;
                }
            }
            
            const year_pattern = /\b(19|20)\d{2}\b/;
            const date_pattern = /\b(0?[1-9]|[12]\d|3[01])[\/\-](0?[1-9]|1[012])[\/\-](19|20)\d{2}\b/;
            if (year_pattern.test(password) || date_pattern.test(password)) {
                predictable += 4;
            }
            
            const quantum_susceptibility = (
                sequential * 0.3 +
                repeated * 0.2 +
                keyboard_walk * 0.4 +
                dictionary_based * 0.5 +
                predictable * 0.6
            );
            
            return Math.min(1.0, quantum_susceptibility / password.length);
        }
        
        // REVOLUTIONARY: Neural network vulnerability assessment
        function calculateNeuralVulnerability(password) {
            // Use basic complexity calculations to avoid recursion
            const spatial_complexity = calculateSpatialComplexity(password);
            const temporal_complexity = calculateTemporalComplexity(password);
            const semantic_complexity = calculateSemanticComplexity(password);
            const contextual_complexity = calculateContextualComplexity(password);
            const behavioral_complexity = calculateBehavioralComplexity(password);
            
            const neural_susceptibility = (
                spatial_complexity * 0.2 +
                temporal_complexity * 0.3 +
                semantic_complexity * 0.4 +
                contextual_complexity * 0.3 +
                behavioral_complexity * 0.2
            );
            
            return Math.min(1.0, neural_susceptibility);
        }
        
        // REVOLUTIONARY: Adaptive learning vulnerability assessment
        function calculateAdaptiveVulnerability(password) {
            const quantum_vulnerability = calculateQuantumVulnerability(password);
            const neural_vulnerability = calculateNeuralVulnerability(password);
            
            const adaptive_susceptibility = (
                quantum_vulnerability * 0.4 +
                neural_vulnerability * 0.6
            );
            
            return Math.min(1.0, adaptive_susceptibility);
        }
        
        // REVOLUTIONARY: Omni-dimensional entropy calculation
        function calculateOmnidimensionalEntropy(password, enable_pattern_analysis = null, enable_social_engineering = null, enable_multi_dimensional = null, enable_ai_penalty = null) {
            const charset = detectCharset(password);
            const base_entropy = password.length * Math.log2(charset);
            
            // Get user preferences (use parameters if provided, otherwise get from DOM)
            const pattern_analysis = enable_pattern_analysis !== null ? enable_pattern_analysis : (document.getElementById('enablePatternAnalysis')?.checked ?? true);
            const social_engineering = enable_social_engineering !== null ? enable_social_engineering : (document.getElementById('enableSocialEngineering')?.checked ?? true);
            const multi_dimensional = enable_multi_dimensional !== null ? enable_multi_dimensional : (document.getElementById('enableMultiVector')?.checked ?? true);
            const ai_penalty_enabled = enable_ai_penalty !== null ? enable_ai_penalty : true;
            
            let pattern_penalty = 0;
            let social_penalty = 0;
            let patterns = { sequential: 0, repeated: 0, keyboard_walk: 0, dictionary_based: 0, predictable: 0, entropy_reduction: 0 };
            
            if (pattern_analysis) {
                patterns = analyzeOmnidimensionalPatterns(password);
                pattern_penalty = patterns.entropy_reduction * base_entropy;
            }
            
            // AI/ML guessing penalty (based on modern AI capabilities)
            const ai_penalty = ai_penalty_enabled ? Math.min(15, base_entropy * 0.3) : 0;
            
            // Social engineering penalty (personal info, common patterns)
            if (social_engineering) {
                social_penalty = patterns.predictable > 0 ? 8 : 0;
            }
            
            // REVOLUTIONARY: Multi-dimensional entropy enhancement
            let multi_dimensional_bonus = 0;
            if (multi_dimensional) {
                multi_dimensional_bonus = (
                    patterns.spatial_complexity * MULTI_DIMENSIONAL_ENTROPY_FACTORS.spatial_complexity +
                    patterns.temporal_complexity * MULTI_DIMENSIONAL_ENTROPY_FACTORS.temporal_complexity +
                    patterns.semantic_complexity * MULTI_DIMENSIONAL_ENTROPY_FACTORS.semantic_complexity +
                    patterns.contextual_complexity * MULTI_DIMENSIONAL_ENTROPY_FACTORS.contextual_complexity +
                    patterns.behavioral_complexity * MULTI_DIMENSIONAL_ENTROPY_FACTORS.behavioral_complexity
                ) * base_entropy * 0.1;
            }
            
            const effective_entropy = Math.max(1, base_entropy - pattern_penalty - ai_penalty - social_penalty + multi_dimensional_bonus);
            
            return {
                base_entropy: base_entropy,
                pattern_penalty: pattern_penalty,
                ai_penalty: ai_penalty,
                social_penalty: social_penalty,
                multi_dimensional_bonus: multi_dimensional_bonus,
                effective_entropy: effective_entropy,
                patterns: patterns
            };
        }
        
        // REVOLUTIONARY: Omni-dimensional attack simulation
        function simulateOmnidimensionalAttack(password, scenario, hash_algo) {
            const entropy_analysis = calculateOmnidimensionalEntropy(password);
            const hardware = HARDWARE_BENCHMARKS[scenario];
            const hash_multiplier = HASH_MULTIPLIERS[hash_algo] || 1.0;
            
            // Get user-defined hardware configuration
            const device_count = parseInt(document.getElementById('deviceCount').value) || 1;
            const core_count = parseInt(document.getElementById('coreCount').value) || 1;
            const parallel_efficiency = parseInt(document.getElementById('parallelEfficiency').value) || 100;
            
            // Calculate effective parallel factor
            const total_cores = device_count * core_count;
            const effective_parallel_factor = total_cores * (parallel_efficiency / 100);
            
            // Check if quantum attacks are enabled
            const enable_quantum_attacks = document.getElementById('enableQuantumAttacks')?.checked ?? true;
            
            let best_time = Infinity;
            let best_attack = '';
            let attack_details = [];
            
            // Filter attack vectors based on enabled options
            let available_attack_vectors = hardware.attack_vectors;
            if (!enable_quantum_attacks) {
                available_attack_vectors = hardware.attack_vectors.filter(vector => !vector.includes('quantum'));
            }
            
            // REVOLUTIONARY: Add omni-dimensional attack vectors
            if (hardware.neural_network_capability > 0) {
                available_attack_vectors.push('neural_network');
            }
            if (hardware.adaptive_learning > 0) {
                available_attack_vectors.push('adaptive_learning');
            }
            if (hardware.quantum_capability > 0) {
                available_attack_vectors.push('quantum_annealing');
            }
            available_attack_vectors.push('multi_dimensional');
            
            // Test each attack vector with omni-dimensional analysis
            for (let attack_vector of available_attack_vectors) {
                const attack_multiplier = ATTACK_VECTOR_MULTIPLIERS[attack_vector] || 1.0;
                
                let attack_time;
                let trials;
                
                // REVOLUTIONARY: Quantum annealing attack
                if (attack_vector === 'quantum_annealing') {
                    const quantum_trials = Math.PI/4 * Math.pow(2, entropy_analysis.effective_entropy/2);
                    const annealing_factor = QUANTUM_ANNEALING_FACTORS.quantum_tunneling;
                    trials = quantum_trials * annealing_factor;
                    attack_time = trials / (hardware.base_speed * hash_multiplier * effective_parallel_factor);
                }
                // REVOLUTIONARY: Neural network attack
                else if (attack_vector === 'neural_network') {
                    const neural_vulnerability = entropy_analysis.patterns.neural_vulnerability;
                    const neural_trials = 0.5 * Math.pow(2, entropy_analysis.effective_entropy * (1 - neural_vulnerability));
                    trials = neural_trials;
                    attack_time = trials / (hardware.base_speed * hash_multiplier * effective_parallel_factor);
                }
                // REVOLUTIONARY: Adaptive learning attack
                else if (attack_vector === 'adaptive_learning') {
                    const adaptive_vulnerability = entropy_analysis.patterns.adaptive_vulnerability;
                    const adaptive_trials = 0.5 * Math.pow(2, entropy_analysis.effective_entropy * (1 - adaptive_vulnerability));
                    trials = adaptive_trials;
                    attack_time = trials / (hardware.base_speed * hash_multiplier * effective_parallel_factor);
                }
                // REVOLUTIONARY: Multi-dimensional attack
                else if (attack_vector === 'multi_dimensional') {
                    const multi_dimensional_factor = (
                        entropy_analysis.patterns.spatial_complexity +
                        entropy_analysis.patterns.temporal_complexity +
                        entropy_analysis.patterns.semantic_complexity +
                        entropy_analysis.patterns.contextual_complexity +
                        entropy_analysis.patterns.behavioral_complexity
                    ) / 5;
                    const multi_trials = 0.5 * Math.pow(2, entropy_analysis.effective_entropy * (1 - multi_dimensional_factor));
                    trials = multi_trials;
                    attack_time = trials / (hardware.base_speed * hash_multiplier * effective_parallel_factor);
                }
                // Classical quantum attack
                else if (attack_vector.includes('quantum')) {
                    trials = Math.PI/4 * Math.pow(2, entropy_analysis.effective_entropy/2);
                    attack_time = trials / (hardware.base_speed * hash_multiplier * effective_parallel_factor);
                }
                // Classical attacks
                else {
                    trials = 0.5 * Math.pow(2, entropy_analysis.effective_entropy);
                    attack_time = trials / (hardware.base_speed * hash_multiplier * effective_parallel_factor);
                }
                
                // Apply user-defined hardware configuration
                attack_time /= effective_parallel_factor;
                
                // Apply availability factor (real-world constraints)
                attack_time /= hardware.availability;
                
                attack_details.push({
                    vector: attack_vector,
                    time: attack_time,
                    trials: trials,
                    speed: hardware.base_speed * attack_multiplier * hash_multiplier
                });
                
                if (attack_time < best_time) {
                    best_time = attack_time;
                    best_attack = attack_vector;
                }
            }
            
            return {
                best_time: best_time,
                best_attack: best_attack,
                all_attacks: attack_details,
                entropy_analysis: entropy_analysis,
                hardware_info: hardware
            };
        }

        // Enhanced time formatting with scientific notation for extreme values
        function formatAdvancedTime(seconds) {
            if (seconds === Infinity || seconds > 1e20) {
                return "practically infinite (beyond universe age)";
            }
            
            if (seconds < 1e-9) {
                return `${(seconds * 1e12).toFixed(2)} picoseconds`;
            }
            
            if (seconds < 1e-6) {
                return `${(seconds * 1e9).toFixed(2)} nanoseconds`;
            }
            
            if (seconds < 1e-3) {
                return `${(seconds * 1e6).toFixed(2)} microseconds`;
            }
            
            if (seconds < 1) {
                return `${(seconds * 1e3).toFixed(2)} milliseconds`;
            }

            // Use the existing formatTime function for normal ranges
            return formatTime(seconds);
        }

        // REVOLUTIONARY OMNIDIMENSIONAL ESTIMATION FUNCTION v3.0
        function estimateOmnidimensional() {
            try {
                const password = document.getElementById('password').value;
                const scenario = document.getElementById('scenario').value;
                const hash_algo = document.getElementById('hash').value;
                const ai_penalty = document.getElementById('hum').checked;
                const show_detailed = document.getElementById('showDetailed').checked;
                const enable_multi_vector = document.getElementById('enableMultiVector').checked;
                const enable_pattern_analysis = document.getElementById('enablePatternAnalysis').checked;
                const enable_quantum_attacks = document.getElementById('enableQuantumAttacks').checked;
                const enable_social_engineering = document.getElementById('enableSocialEngineering').checked;
                
                if (!password) {
                    showResult('⚠️  Enter a password to analyze.', 'error', false);
                    return;
                }

            // Calculate baseline (all features disabled) for comparison
            const baseline_entropy = calculateOmnidimensionalEntropy(password, false, false, false, false);
            const hardware = HARDWARE_BENCHMARKS[scenario];
            const hash_multiplier = HASH_MULTIPLIERS[hash_algo] || 1.0;
            const device_count = parseInt(document.getElementById('deviceCount').value) || 1;
            const core_count = parseInt(document.getElementById('coreCount').value) || 1;
            const parallel_efficiency = parseInt(document.getElementById('parallelEfficiency').value) || 100;
            const total_cores = device_count * core_count;
            const effective_parallel_factor = total_cores * (parallel_efficiency / 100);
            
            let baseline_time;
            if (scenario === 'quantum') {
                const quantum_trials = Math.PI/4 * Math.pow(2, baseline_entropy.effective_entropy/2);
                baseline_time = quantum_trials / (hardware.base_speed * hash_multiplier * effective_parallel_factor);
            } else {
                const classical_trials = 0.5 * Math.pow(2, baseline_entropy.effective_entropy);
                baseline_time = classical_trials / (hardware.base_speed * hash_multiplier * effective_parallel_factor);
            }

            // Perform omni-dimensional analysis based on enabled options
            let attack_result;
            
            if (enable_multi_vector) {
                attack_result = simulateOmnidimensionalAttack(password, scenario, hash_algo);
            } else {
                // Fallback to simple calculation if multi-vector is disabled
                const entropy_analysis = calculateOmnidimensionalEntropy(password);
                
                let attack_time;
                if (scenario === 'quantum' && enable_quantum_attacks) {
                    const quantum_trials = Math.PI/4 * Math.pow(2, entropy_analysis.effective_entropy/2);
                    attack_time = quantum_trials / (hardware.base_speed * hash_multiplier * effective_parallel_factor);
                } else {
                    const classical_trials = 0.5 * Math.pow(2, entropy_analysis.effective_entropy);
                    attack_time = classical_trials / (hardware.base_speed * hash_multiplier * effective_parallel_factor);
                }
                
                attack_result = {
                    best_time: attack_time,
                    best_attack: scenario === 'quantum' ? 'grover_quantum' : 'brute_force',
                    all_attacks: [{
                        vector: scenario === 'quantum' ? 'grover_quantum' : 'brute_force',
                        time: attack_time,
                        trials: scenario === 'quantum' ? 
                            Math.PI/4 * Math.pow(2, entropy_analysis.effective_entropy/2) :
                            0.5 * Math.pow(2, entropy_analysis.effective_entropy),
                        speed: hardware.base_speed * hash_multiplier
                    }],
                    entropy_analysis: entropy_analysis,
                    hardware_info: hardware
                };
            }
            
            // Apply additional AI penalty if requested
            if (ai_penalty) {
                attack_result.best_time *= 0.1; // 10x faster with AI assistance
            }

            // Calculate timing differences for each feature
            const timing_differences = {
                baseline: baseline_time,
                current: attack_result.best_time,
                multi_vector: enable_multi_vector ? (baseline_time / attack_result.best_time) : 1,
                pattern_analysis: enable_pattern_analysis ? (baseline_time / attack_result.best_time) : 1,
                quantum_attacks: enable_quantum_attacks ? (baseline_time / attack_result.best_time) : 1,
                social_engineering: enable_social_engineering ? (baseline_time / attack_result.best_time) : 1,
                ai_penalty: ai_penalty ? 10 : 1 // AI penalty makes it 10x faster
            };
            
            // REVOLUTIONARY: Generate omni-dimensional result
            let result_text = 
                `🚀 REVOLUTIONARY OMNIDIMENSIONAL PASSWORD ANALYSIS v3.0\n` +
                `═══════════════════════════════════════════════════════\n` +
                `🌟 "The Omni-Algorithm" - Calculates Everything\n\n` +
                
                `📊 OMNIDIMENSIONAL ENTROPY ANALYSIS:\n` +
                `• Base Entropy: ${attack_result.entropy_analysis.base_entropy.toFixed(2)} bits\n` +
                `• Effective Entropy: ${attack_result.entropy_analysis.effective_entropy.toFixed(2)} bits\n` +
                `• Pattern Penalty: -${attack_result.entropy_analysis.pattern_penalty.toFixed(2)} bits\n` +
                `• AI Guessing Penalty: -${attack_result.entropy_analysis.ai_penalty.toFixed(2)} bits\n` +
                `• Social Engineering Penalty: -${attack_result.entropy_analysis.social_penalty.toFixed(2)} bits\n` +
                `• Multi-Dimensional Bonus: +${attack_result.entropy_analysis.multi_dimensional_bonus.toFixed(2)} bits\n\n` +
                
                `🎯 REVOLUTIONARY ATTACK STRATEGY:\n` +
                `• Optimal Attack Vector: ${attack_result.best_attack.toUpperCase()}\n` +
                `• Hardware Platform: ${scenario.toUpperCase()}\n` +
                `• Hash Algorithm: ${hash_algo}\n` +
                `• AI Assistance: ${ai_penalty ? 'ENABLED' : 'DISABLED'}\n\n` +
                
                `⚙️  HARDWARE CONFIGURATION:\n` +
                `• Devices/Units: ${device_count.toLocaleString()}\n` +
                `• Cores per Device: ${core_count.toLocaleString()}\n` +
                `• Total Cores: ${total_cores.toLocaleString()}\n` +
                `• Parallel Efficiency: ${parallel_efficiency}%\n` +
                `• Effective Parallel Factor: ${effective_parallel_factor.toFixed(1)}x\n\n` +
                
                `⏱️  CRACK TIME ESTIMATE:\n` +
                `${formatAdvancedTime(attack_result.best_time)}\n\n` +
                
                `⚡ TIMING DIFFERENCE ANALYSIS:\n` +
                `• Baseline Time (no features): ${formatAdvancedTime(timing_differences.baseline)}\n` +
                `• Current Time (with features): ${formatAdvancedTime(timing_differences.current)}\n` +
                `• Speed Difference: ${timing_differences.baseline > timing_differences.current ? 
                    `${(timing_differences.baseline / timing_differences.current).toFixed(1)}x FASTER` : 
                    `${(timing_differences.current / timing_differences.baseline).toFixed(1)}x SLOWER`}\n` +
                `• Multi-Vector Impact: ${enable_multi_vector ? `${timing_differences.multi_vector.toFixed(1)}x faster` : 'Disabled'}\n` +
                `• Pattern Analysis Impact: ${enable_pattern_analysis ? `${timing_differences.pattern_analysis.toFixed(1)}x faster` : 'Disabled'}\n` +
                `• Quantum Attacks Impact: ${enable_quantum_attacks ? `${timing_differences.quantum_attacks.toFixed(1)}x faster` : 'Disabled'}\n` +
                `• Social Engineering Impact: ${enable_social_engineering ? `${timing_differences.social_engineering.toFixed(1)}x faster` : 'Disabled'}\n` +
                `• AI Penalty Impact: ${ai_penalty ? `${timing_differences.ai_penalty.toFixed(1)}x faster` : 'Disabled'}\n\n` +
                
                `🔍 REVOLUTIONARY PATTERN ANALYSIS:\n` +
                `• Sequential Patterns: ${attack_result.entropy_analysis.patterns.sequential} chars\n` +
                `• Repeated Characters: ${attack_result.entropy_analysis.patterns.repeated} chars\n` +
                `• Keyboard Walks: ${attack_result.entropy_analysis.patterns.keyboard_walk} chars\n` +
                `• Dictionary-Based: ${attack_result.entropy_analysis.patterns.dictionary_based} chars\n` +
                `• Predictable Elements: ${attack_result.entropy_analysis.patterns.predictable} chars\n\n` +
                
                `🌌 MULTI-DIMENSIONAL COMPLEXITY: <i class="fas fa-info-circle complexity-info-icon" title="Multi-dimensional complexity analysis">
                    <div class="complexity-tooltip">
                        <h4>Multi-Dimensional Complexity Analysis</h4>
                        <p>Advanced password analysis across five dimensions to assess resistance to modern attack vectors:</p>
                        <ul>
                            <li><strong>Spatial:</strong> Character distribution and clustering patterns</li>
                            <li><strong>Temporal:</strong> Typing behavior and rhythm analysis</li>
                            <li><strong>Semantic:</strong> Meaningful content and context detection</li>
                            <li><strong>Contextual:</strong> Personal and cultural pattern identification</li>
                            <li><strong>Behavioral:</strong> Human behavioral pattern analysis</li>
                        </ul>
                    </div>
                </i>\n` +
                `• Spatial Complexity: ${(attack_result.entropy_analysis.patterns.spatial_complexity * 100).toFixed(1)}% <i class="fas fa-info-circle complexity-info-icon" title="Spatial complexity analysis">
                    <div class="complexity-tooltip">
                        <h4>Spatial Complexity</h4>
                        <p>Analyzes how characters are distributed throughout the password:</p>
                        <ul>
                            <li>Measures clustering of repeated characters</li>
                            <li>Calculates average distance between positions</li>
                            <li>Higher scores = better spatial distribution</li>
                            <li>Resists pattern-based attacks</li>
                        </ul>
                    </div>
                </i>\n` +
                `• Temporal Complexity: ${(attack_result.entropy_analysis.patterns.temporal_complexity * 100).toFixed(1)}% <i class="fas fa-info-circle complexity-info-icon" title="Temporal complexity analysis">
                    <div class="complexity-tooltip">
                        <h4>Temporal Complexity</h4>
                        <p>Evaluates patterns related to typing behavior:</p>
                        <ul>
                            <li>Analyzes character frequency distribution</li>
                            <li>Measures variance in character usage</li>
                            <li>Identifies predictable typing rhythms</li>
                            <li>Higher scores = more random typing patterns</li>
                        </ul>
                    </div>
                </i>\n` +
                `• Semantic Complexity: ${(attack_result.entropy_analysis.patterns.semantic_complexity * 100).toFixed(1)}% <i class="fas fa-info-circle complexity-info-icon" title="Semantic complexity analysis">
                    <div class="complexity-tooltip">
                        <h4>Semantic Complexity</h4>
                        <p>Assesses meaningful content and context:</p>
                        <ul>
                            <li>Detects common words (password, admin, user)</li>
                            <li>Evaluates presence of numbers and symbols</li>
                            <li>Penalizes semantically meaningful content</li>
                            <li>Higher scores = less predictable meaning</li>
                        </ul>
                    </div>
                </i>\n` +
                `• Contextual Complexity: ${(attack_result.entropy_analysis.patterns.contextual_complexity * 100).toFixed(1)}% <i class="fas fa-info-circle complexity-info-icon" title="Contextual complexity analysis">
                    <div class="complexity-tooltip">
                        <h4>Contextual Complexity</h4>
                        <p>Identifies personal and cultural patterns:</p>
                        <ul>
                            <li>Detects dates, years, months, days</li>
                            <li>Finds personal information patterns</li>
                            <li>Identifies cultural references</li>
                            <li>Higher scores = less personal/cultural content</li>
                        </ul>
                    </div>
                </i>\n` +
                `• Behavioral Complexity: ${(attack_result.entropy_analysis.patterns.behavioral_complexity * 100).toFixed(1)}% <i class="fas fa-info-circle complexity-info-icon" title="Behavioral complexity analysis">
                    <div class="complexity-tooltip">
                        <h4>Behavioral Complexity</h4>
                        <p>Analyzes human behavioral patterns:</p>
                        <ul>
                            <li>Mixed case usage patterns</li>
                            <li>Alternating character types</li>
                            <li>Randomness distribution analysis</li>
                            <li>Higher scores = more unpredictable behavior</li>
                        </ul>
                    </div>
                </i>\n\n` +
                
                `⚛️  QUANTUM VULNERABILITY ASSESSMENT:\n` +
                `• Quantum Vulnerability: ${(attack_result.entropy_analysis.patterns.quantum_vulnerability * 100).toFixed(1)}%\n` +
                `• Neural Network Vulnerability: ${(attack_result.entropy_analysis.patterns.neural_vulnerability * 100).toFixed(1)}%\n` +
                `• Adaptive Learning Vulnerability: ${(attack_result.entropy_analysis.patterns.adaptive_vulnerability * 100).toFixed(1)}%\n`;

            console.log('Show detailed checkbox value:', show_detailed);
            console.log('Attack result all_attacks:', attack_result.all_attacks);
            console.log('Attack result hardware_info:', attack_result.hardware_info);
            
            if (show_detailed) {
                console.log('Adding detailed stats section...');
                result_text += `\n<details class="attack-analysis-dropdown">
<summary style="cursor: pointer; font-weight: bold; color: #4CAF50; padding: 8px; background: #f0f8f0; border-radius: 4px; margin: 8px 0;">
📈 REVOLUTIONARY ATTACK VECTOR ANALYSIS (Click to expand)
</summary>
<div style="padding: 12px; background: #f9f9f9; border-left: 3px solid #4CAF50; margin: 8px 0;">`;
                
                for (let attack of attack_result.all_attacks) {
                    result_text += `• ${attack.vector.toUpperCase()}: ${formatAdvancedTime(attack.time)}\n`;
                }
                
                result_text += `</div>
</details>

<details class="hardware-specs-dropdown">
<summary style="cursor: pointer; font-weight: bold; color: #2196F3; padding: 8px; background: #f0f8ff; border-radius: 4px; margin: 8px 0;">
⚡ ADVANCED HARDWARE SPECIFICATIONS (Click to expand)
</summary>
<div style="padding: 12px; background: #f9f9f9; border-left: 3px solid #2196F3; margin: 8px 0;">
• Base Speed: ${attack_result.hardware_info.base_speed.toExponential(2)} ops/sec\n` +
                    `• Parallel Factor: ${attack_result.hardware_info.parallel_factor}x\n` +
                    `• Cost Factor: $${attack_result.hardware_info.cost_factor.toLocaleString()}\n` +
                    `• Availability: ${(attack_result.hardware_info.availability * 100).toFixed(1)}%\n` +
                    `• Quantum Capability: ${(attack_result.hardware_info.quantum_capability * 100).toFixed(1)}%\n` +
                    `• Neural Network Capability: ${(attack_result.hardware_info.neural_network_capability * 100).toFixed(1)}%\n` +
                    `• Adaptive Learning: ${(attack_result.hardware_info.adaptive_learning * 100).toFixed(1)}%\n` +
                    `• Attack Vectors: ${attack_result.hardware_info.attack_vectors.join(', ')}\n` +
                    `</div>
</details>`;
                console.log('Detailed stats section added successfully');
            } else {
                console.log('Show detailed is false, skipping detailed stats');
            }

            console.log('Final result text length:', result_text.length);
            console.log('Result contains detailed stats:', result_text.includes('REVOLUTIONARY ATTACK VECTOR ANALYSIS'));
            showResult(result_text, 'success', false);
            } catch (error) {
                console.error('Error in estimateOmnidimensional:', error);
                showResult(`❌ Error calculating password strength: ${error.message}`, 'error', false);
            }
        }

        // Enhanced password strength assessment
        function assessPasswordStrength(password) {
            const entropy_analysis = calculateOmnidimensionalEntropy(password);
            const patterns = entropy_analysis.patterns;
            
            let score = 0;
            let feedback = [];
            
            // Length scoring based on new criteria (0-25 points)
            if (password.length >= 520) score += 25; // Extra Strong
            else if (password.length >= 128) score += 25; // Strong
            else if (password.length >= 50) score += 20; // Moderate
            else if (password.length >= 12) score += 15;
            else if (password.length >= 10) score += 12;
            else if (password.length >= 8) score += 10;
            else if (password.length >= 6) score += 8;
            else score += 5;
            
            // Character diversity (0-25 points)
            const has_lower = /[a-z]/.test(password);
            const has_upper = /[A-Z]/.test(password);
            const has_digit = /\d/.test(password);
            const has_special = /[^A-Za-z0-9]/.test(password);
            
            score += (has_lower + has_upper + has_digit + has_special) * 6.25;
            
            // Pattern penalty (0-25 points deducted)
            const pattern_penalty = Math.min(25, (patterns.sequential + patterns.repeated + 
                                                 patterns.keyboard_walk + patterns.dictionary_based + 
                                                 patterns.predictable) * 2);
            score -= pattern_penalty;
            
            // Entropy bonus (0-25 points)
            const entropy_bonus = Math.min(25, entropy_analysis.effective_entropy / 4);
            score += entropy_bonus;
            
            score = Math.max(0, Math.min(100, score));
            
            // Generate feedback
            if (password.length < 8) feedback.push("Increase length to at least 8 characters");
            if (!has_lower) feedback.push("Add lowercase letters");
            if (!has_upper) feedback.push("Add uppercase letters");
            if (!has_digit) feedback.push("Add numbers");
            if (!has_special) feedback.push("Add special characters");
            if (patterns.sequential > 0) feedback.push("Avoid sequential patterns");
            if (patterns.repeated > 0) feedback.push("Avoid repeated characters");
            if (patterns.keyboard_walk > 0) feedback.push("Avoid keyboard walks");
            if (patterns.dictionary_based > 0) feedback.push("Avoid dictionary words");
            if (patterns.predictable > 0) feedback.push("Avoid predictable patterns");
            
            let strength = '';
            let strengthClass = '';
            
            // New length-based strength determination
            if (password.length >= 520) {
                strength = 'Extra Strong';
                strengthClass = 'strength-extra-strong';
            } else if (password.length >= 128) {
                strength = 'Strong';
                strengthClass = 'strength-strong';
            } else if (password.length >= 50) {
                strength = 'Moderate';
                strengthClass = 'strength-moderate';
            } else if (score >= 80) {
                strength = 'Excellent';
                strengthClass = 'strength-very-strong';
            } else if (score >= 60) {
                strength = 'Strong';
                strengthClass = 'strength-strong';
            } else if (score >= 40) {
                strength = 'Moderate';
                strengthClass = 'strength-moderate';
            } else if (score >= 20) {
                strength = 'Weak';
                strengthClass = 'strength-weak';
            } else {
                strength = 'Very Weak';
                strengthClass = 'strength-very-weak';
            }
            
            return {
                score: score,
                strength: strength,
                strengthClass: strengthClass,
                feedback: feedback,
                entropy: entropy_analysis.effective_entropy
            };
        }

        // Update the existing functions to use the new algorithm
        function updatePasswordInfo() {
            const password = document.getElementById('password').value;
            const passwordInfo = document.getElementById('passwordInfo');
            const entropyDisplay = document.getElementById('entropyDisplay');
            const entropyValue = document.getElementById('entropyValue');
            const strengthIndicator = document.getElementById('strengthIndicator');
            
            if (password) {
                try {
                    const assessment = assessPasswordStrength(password);
                    const entropy_analysis = calculateOmnidimensionalEntropy(password);
                    
                    // Update password info
                    passwordInfo.textContent = `Length: ${password.length} chars | Effective Entropy: ${entropy_analysis.effective_entropy.toFixed(1)} bits | Score: ${assessment.score}/100 (${assessment.strength})`;
                    passwordInfo.style.display = 'block';
                    
                    // Update live entropy display
                    if (entropyValue) entropyValue.textContent = entropy_analysis.effective_entropy.toFixed(1);
                    if (strengthIndicator) {
                        strengthIndicator.textContent = assessment.strength;
                        strengthIndicator.className = `strength-indicator ${assessment.strengthClass}`;
                    }
                    if (entropyDisplay) entropyDisplay.style.display = 'block';
                    
                    // Show live update indicator
                    showLiveUpdateIndicator();
                } catch (error) {
                    console.error('Error in updatePasswordInfo:', error);
                    passwordInfo.textContent = `Length: ${password.length} chars | Error calculating entropy`;
                    passwordInfo.style.display = 'block';
                }
            } else {
                passwordInfo.style.display = 'none';
                if (entropyDisplay) entropyDisplay.style.display = 'none';
            }
        }

        // Initialize the enhanced system
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize defaults first
            pullLiveDefaults();
            setDefaults();
            
            // Set up event listeners for real-time updates
            document.getElementById('password').addEventListener('input', function() {
                updatePasswordInfo();
                updatePasswordLength();
                
                // Auto-calculate with new algorithm
                setTimeout(() => {
                    if (this.value.length > 3) {
                        try {
                            estimateOmnidimensional();
                        } catch (error) {
                            console.error('Error in auto-calculation:', error);
                        }
                    }
                }, 1000);
            });
            
            // Update other event listeners to use the new algorithm
            document.getElementById('scenario').addEventListener('change', function() {
                setDefaults();
                if (document.getElementById('password').value) {
                    try {
                        estimateOmnidimensional();
                    } catch (error) {
                        console.error('Error in scenario change:', error);
                    }
                }
            });
            
            document.getElementById('hash').addEventListener('change', function() {
                updateHashInfo();
                if (document.getElementById('password').value) {
                    try {
                        estimateOmnidimensional();
                    } catch (error) {
                        console.error('Error in hash change:', error);
                    }
                }
            });
            
            document.getElementById('hum').addEventListener('change', function() {
                if (document.getElementById('password').value) {
                    try {
                        estimateOmnidimensional();
                    } catch (error) {
                        console.error('Error in AI penalty change:', error);
                    }
                }
            });
            
            // Add event listeners for new attack vector options
            document.getElementById('enableMultiVector').addEventListener('change', function() {
                if (document.getElementById('password').value) {
                    try {
                        estimateOmnidimensional();
                    } catch (error) {
                        console.error('Error in multi-vector change:', error);
                    }
                }
            });
            
            document.getElementById('enablePatternAnalysis').addEventListener('change', function() {
                if (document.getElementById('password').value) {
                    try {
                        estimateOmnidimensional();
                    } catch (error) {
                        console.error('Error in pattern analysis change:', error);
                    }
                }
            });
            
            document.getElementById('enableQuantumAttacks').addEventListener('change', function() {
                if (document.getElementById('password').value) {
                    try {
                        estimateOmnidimensional();
                    } catch (error) {
                        console.error('Error in quantum attacks change:', error);
                    }
                }
            });
            
            document.getElementById('enableSocialEngineering').addEventListener('change', function() {
                if (document.getElementById('password').value) {
                    try {
                        estimateOmnidimensional();
                    } catch (error) {
                        console.error('Error in social engineering change:', error);
                    }
                }
            });
            
            // Add event listeners for hardware configuration
            document.getElementById('deviceCount').addEventListener('input', function() {
                if (document.getElementById('password').value) {
                    try {
                        estimateOmnidimensional();
                    } catch (error) {
                        console.error('Error in device count change:', error);
                    }
                }
            });
            
            document.getElementById('coreCount').addEventListener('input', function() {
                if (document.getElementById('password').value) {
                    try {
                        estimateOmnidimensional();
                    } catch (error) {
                        console.error('Error in core count change:', error);
                    }
                }
            });
            
            document.getElementById('parallelEfficiency').addEventListener('input', function() {
                if (document.getElementById('password').value) {
                    try {
                        estimateOmnidimensional();
                    } catch (error) {
                        console.error('Error in parallel efficiency change:', error);
                    }
                }
            });
            
            // Initialize displays
            updatePasswordInfo();
            updatePasswordLength();
            updateHashInfo();
            
            // Show welcome message
            setTimeout(() => {
                showResult('🚀 Welcome to the Revolutionary Omni-Dimensional Password Analysis v3.0!\n\n🌟 "The Omni-Algorithm" - Calculates Everything\n\nThis revolutionary tool incorporates:\n• Multi-dimensional entropy analysis\n• Quantum annealing algorithms\n• Neural network pattern recognition\n• Adaptive learning vulnerability assessment\n• Spatial, temporal, semantic complexity analysis\n• Behavioral and contextual pattern detection\n• Revolutionary attack vector simulation\n• Real-world hardware benchmarks\n\nYour password is analyzed locally and never sent to any server.', 'success', false);
            }, 500);
        });

        // Missing functions that need to be included for compatibility
        function detectCharset(password) {
            if (!password) return 95; // Default to full ASCII if no password
            
            let hasLower = false, hasUpper = false, hasDigit = false, hasSymbol = false;
            
            for (let char of password) {
                if (char >= 'a' && char <= 'z') hasLower = true;
                else if (char >= 'A' && char <= 'Z') hasUpper = true;
                else if (char >= '0' && char <= '9') hasDigit = true;
                else hasSymbol = true;
            }
            
            if (hasSymbol) return 95; // Full ASCII printable
            if (hasDigit) return 62;  // Alphanumeric
            if (hasUpper) return 52;  // Letters only
            return 26; // Lowercase only
        }
        
        function updatePasswordLength() {
            const password = document.getElementById('password').value;
            const passwordLengthField = document.getElementById('passwordLength');
            
            if (passwordLengthField) {
                if (password) {
                    passwordLengthField.textContent = `${password.length} characters`;
                } else {
                    passwordLengthField.textContent = 'Enter password above to see length';
                }
            } else {
                console.error('Password length field not found');
            }
        }
        
        function updateHashInfo() {
            const hashSelect = document.getElementById('hash');
            const hashInfo = document.getElementById('hashInfo');
            
            let info = '';
            switch(hashSelect.value) {
                case 'MD5':
                    info = 'What is this? MD5 is a fast but insecure hash. Many websites still use it. Cracking is very fast.';
                    break;
                case 'SHA256':
                    info = 'What is this? SHA256 is a secure hash used by Bitcoin and many modern systems. Moderate cracking speed.';
                    break;
                case 'bcrypt':
                    info = 'What is this? bcrypt is designed to be slow and secure. Used by many modern websites. Slow to crack.';
                    break;
                case 'argon2':
                    info = 'What is this? Argon2 is the most secure hash, designed to be very slow. Used by password managers. Very slow to crack.';
                    break;
            }
            
            hashInfo.textContent = info;
            hashInfo.style.display = info ? 'block' : 'none';
        }
        
        function showLiveUpdateIndicator() {
            const indicator = document.getElementById('liveUpdateIndicator');
            indicator.classList.add('show');
            setTimeout(() => {
                indicator.classList.remove('show');
            }, 2000);
        }
        
        function showResult(text, type, autoScroll = false) {
            console.log('showResult called with:', { text: text.substring(0, 200) + '...', type, autoScroll });
            const resultDiv = document.getElementById('result');
            if (!resultDiv) {
                console.error('Result div not found!');
                return;
            }
            // Use innerHTML to render HTML content (for dropdowns)
            resultDiv.innerHTML = text;
            resultDiv.className = `result-container ${type}`;
            resultDiv.style.display = 'block';
            console.log('Result displayed, length:', text.length);
            
            // Only scroll to result if explicitly requested (manual calculation)
            if (autoScroll) {
                resultDiv.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }
        
        // Time unit constants in seconds (using precise average values)
        const SECONDS_PER_YEAR = 31557600;    // 365.25 days * 24 * 60 * 60
        const SECONDS_PER_MONTH = 2629800;   // SECONDS_PER_YEAR / 12 ≈ 30.4375 days
        const SECONDS_PER_WEEK = 604800;     // 7 days * 24 * 60 * 60
        const SECONDS_PER_DAY = 86400;       // 24 hours * 60 * 60
        const SECONDS_PER_HOUR = 3600;       // 60 minutes * 60
        const SECONDS_PER_MINUTE = 60;       // 60 seconds

        // Function to format total seconds into the specified time breakdown
        function formatTime(totalSeconds) {
            // Handle special cases
            if (totalSeconds === Infinity) {
                return "infinite time";
            }
            if (totalSeconds < 0) {
                return "invalid time (negative duration)";
            }
            if (totalSeconds > 1e18) {
                const years = totalSeconds / SECONDS_PER_YEAR;
                return "approximately " + years.toExponential(2) + " years";
            }

            // Calculate each unit sequentially
            const years = Math.floor(totalSeconds / SECONDS_PER_YEAR);
            let remainingSeconds = totalSeconds - (years * SECONDS_PER_YEAR);

            const months = Math.floor(remainingSeconds / SECONDS_PER_MONTH);
            remainingSeconds -= months * SECONDS_PER_MONTH;

            const weeks = Math.floor(remainingSeconds / SECONDS_PER_WEEK);
            remainingSeconds -= weeks * SECONDS_PER_WEEK;

            const days = Math.floor(remainingSeconds / SECONDS_PER_DAY);
            remainingSeconds -= days * SECONDS_PER_DAY;

            const hours = Math.floor(remainingSeconds / SECONDS_PER_HOUR);
            remainingSeconds -= hours * SECONDS_PER_HOUR;

            const minutes = Math.floor(remainingSeconds / SECONDS_PER_MINUTE);
            remainingSeconds -= minutes * SECONDS_PER_MINUTE;

            const seconds = Math.floor(remainingSeconds);
            remainingSeconds -= seconds;

            // Calculate milliseconds and microseconds from the fractional part
            const milliseconds = Math.floor(remainingSeconds * 1000);
            const microseconds = Math.floor((remainingSeconds - (milliseconds / 1000)) * 1000000);

            // Return the formatted string
            return `${years} Year(s) ${months} Month(s) ${weeks} weeks ${days} Day ${hours} Hours ${minutes} Minutes ${seconds} sec ${milliseconds} mill secs ${microseconds} micro secs`;
        }
        
        // Update the button to use the new algorithm
        document.querySelector('.calculate-btn').onclick = function() {
            estimateOmnidimensional();
        };
    </script>
    
    <!-- Navigation and UI Scripts -->
    <script src="brain-script.js"></script>
    <script src="shared-loader.js"></script>
    <script src="mobile-nav.js"></script>
    <script src="sphere-loader.js"></script>
    
    <script src="security-enhancement.js"></script>
<!--Start of Tawk.to Script-->
<script type="text/javascript">
var Tawk_API=Tawk_API||{}, Tawk_LoadStart=new Date();
(function(){
var s1=document.createElement("script"),s0=document.getElementsByTagName("script")[0];
s1.async=true;
s1.src='https://embed.tawk.to/688b284b9abe48192a749848/1j1s0h5i3';
s1.charset='UTF-8';
s1.setAttribute('crossorigin','*');
s0.parentNode.insertBefore(s1,s0);
})();
</script>
<!--End of Tawk.to Script-->

  </body>
</html> 