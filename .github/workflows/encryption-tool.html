<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Advanced Encryption & Decryption Tool - A.Insiders</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/@open-quantum-safe/liboqs-wasm@0.17.1/dist/liboqs.js"></script>
  <style>
    :root {
      --bg-primary: #000000;
      --bg-secondary: #0a0a0a;
      --bg-tertiary: #111111;
      --accent-primary: #0066ff;
      --accent-secondary: #0052cc;
      --accent-blue: #4d94ff;
      --text-primary: #ffffff;
      --text-secondary: #cccccc;
      --text-muted: #888888;
      --border-color: rgba(0, 102, 255, 0.2);
      --border-radius: 12px;
      --shadow-glow: 0 0 30px rgba(0, 102, 255, 0.3);
      --shadow-dark: 0 10px 40px rgba(0, 0, 0, 0.6);
      --font-primary: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      --transition-smooth: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      --transition-fast: all 0.15s ease;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: var(--font-primary);
      background: var(--bg-primary);
      color: var(--text-primary);
      line-height: 1.6;
      min-height: 100vh;
      position: relative;
      overflow-x: hidden;
    }

    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(circle at 20% 80%, rgba(0, 102, 255, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 80% 20%, rgba(77, 148, 255, 0.1) 0%, transparent 50%);
      pointer-events: none;
      z-index: -1;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 2rem;
    }

    .header {
      text-align: center;
      margin-bottom: 3rem;
      position: relative;
    }

    .header::after {
      content: '';
      position: absolute;
      bottom: -1rem;
      left: 50%;
      transform: translateX(-50%);
      width: 100px;
      height: 3px;
      background: linear-gradient(90deg, transparent, var(--accent-primary), transparent);
      border-radius: 2px;
    }

    .header h1 {
      font-size: 2.5rem;
      font-weight: 700;
      margin-bottom: 0.5rem;
      background: linear-gradient(135deg, var(--text-primary), var(--accent-blue));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .header p {
      color: var(--text-secondary);
      font-size: 1.1rem;
    }

    .tabs-container {
      background: var(--bg-secondary);
      border-radius: var(--border-radius);
      padding: 1rem;
      margin-bottom: 2rem;
      border: 1px solid var(--border-color);
      box-shadow: var(--shadow-dark);
    }

    .tabs {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .tab-button {
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      padding: 1rem 1.5rem;
      border-radius: var(--border-radius);
      cursor: pointer;
      font-weight: 500;
      color: var(--text-secondary);
      transition: var(--transition-smooth);
      position: relative;
      overflow: hidden;
      flex: 1;
      min-width: 140px;
    }

    .tab-button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(0, 102, 255, 0.1), transparent);
      transition: var(--transition-smooth);
    }

    .tab-button:hover::before {
      left: 100%;
    }

    .tab-button:hover {
      border-color: var(--accent-primary);
      color: var(--text-primary);
      transform: translateY(-2px);
      box-shadow: var(--shadow-glow);
    }

    .tab-button.active {
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      border-color: var(--accent-primary);
      color: var(--text-primary);
      box-shadow: var(--shadow-glow);
    }

    .tab {
      display: none;
      animation: fadeInUp 0.3s ease-out;
    }

    .tab.active {
      display: block;
    }

    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .card {
      background: var(--bg-secondary);
      border-radius: var(--border-radius);
      padding: 2rem;
      margin-bottom: 2rem;
      border: 1px solid var(--border-color);
      box-shadow: var(--shadow-dark);
      transition: var(--transition-smooth);
    }

    .card:hover {
      border-color: var(--accent-primary);
      box-shadow: var(--shadow-glow);
      transform: translateY(-5px);
    }

    .card h3 {
      font-size: 1.5rem;
      font-weight: 600;
      margin-bottom: 1.5rem;
      color: var(--accent-blue);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .card h3::before {
      content: 'üîê';
      font-size: 1.2rem;
    }

    .form-group {
      margin-bottom: 1.5rem;
      position: relative;
    }

    .form-group label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: 500;
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .info-btn {
      background: none;
      border: none;
      color: var(--accent-blue);
      cursor: pointer;
      font-size: 1.1rem;
      padding: 0.2rem;
      border-radius: 50%;
      transition: var(--transition-fast);
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .info-btn:hover {
      background: rgba(0, 102, 255, 0.1);
      transform: scale(1.1);
    }

    .form-control {
      width: 100%;
      padding: 1rem;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: var(--border-radius);
      color: var(--text-primary);
      font-family: var(--font-primary);
      transition: var(--transition-smooth);
      resize: vertical;
    }

    .form-control:focus {
      outline: none;
      border-color: var(--accent-primary);
      box-shadow: 0 0 0 3px rgba(0, 102, 255, 0.1);
    }

    .form-control::placeholder {
      color: var(--text-muted);
    }

    select.form-control {
      cursor: pointer;
    }

    .btn {
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      border: none;
      padding: 1rem 2rem;
      border-radius: var(--border-radius);
      color: var(--text-primary);
      font-weight: 600;
      cursor: pointer;
      transition: var(--transition-smooth);
      position: relative;
      overflow: hidden;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
    }

    .btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
      transition: var(--transition-smooth);
    }

    .btn:hover::before {
      left: 100%;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-glow);
    }

    .btn:active {
      transform: translateY(0);
    }

    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
    }

    .btn-secondary {
      background: linear-gradient(135deg, var(--bg-tertiary), var(--bg-secondary));
      border: 1px solid var(--border-color);
    }

    .btn-secondary:hover {
      border-color: var(--accent-primary);
    }

    .result-container {
      background: var(--bg-tertiary);
      border-radius: var(--border-radius);
      padding: 1.5rem;
      margin-top: 1.5rem;
      border: 1px solid var(--border-color);
      position: relative;
    }

    .result-container::before {
      content: 'üìã';
      position: absolute;
      top: -0.5rem;
      left: 1rem;
      background: var(--bg-secondary);
      padding: 0.5rem;
      border-radius: 50%;
      font-size: 0.8rem;
    }

    .result-label {
      font-weight: 600;
      color: var(--accent-blue);
      margin-bottom: 0.5rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .copy-btn {
      background: none;
      border: none;
      color: var(--accent-blue);
      cursor: pointer;
      padding: 0.5rem;
      border-radius: 50%;
      transition: var(--transition-fast);
      margin-left: auto;
    }

    .copy-btn:hover {
      background: rgba(0, 102, 255, 0.1);
      transform: scale(1.1);
    }

    .copy-btn.copied {
      color: #00ff00;
    }

    .status-indicator {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 1rem;
      border-radius: var(--border-radius);
      font-weight: 500;
      margin-top: 1rem;
    }

    .status-success {
      background: rgba(0, 255, 0, 0.1);
      color: #00ff00;
      border: 1px solid rgba(0, 255, 0, 0.3);
    }

    .status-error {
      background: rgba(255, 0, 0, 0.1);
      color: #ff4444;
      border: 1px solid rgba(255, 0, 0, 0.3);
    }

    .status-loading {
      background: rgba(0, 102, 255, 0.1);
      color: var(--accent-blue);
      border: 1px solid rgba(0, 102, 255, 0.3);
    }

    .spinner {
      width: 16px;
      height: 16px;
      border: 2px solid transparent;
      border-top: 2px solid currentColor;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .popup {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--bg-secondary);
      padding: 2rem;
      border-radius: var(--border-radius);
      box-shadow: var(--shadow-dark);
      max-width: 400px;
      z-index: 1000;
      border: 1px solid var(--border-color);
    }

    .popup-close {
      position: absolute;
      top: 1rem;
      right: 1rem;
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 1.5rem;
      transition: var(--transition-fast);
    }

    .popup-close:hover {
      color: var(--text-primary);
    }

    .overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 999;
      backdrop-filter: blur(5px);
    }

    .key-display {
      background: var(--bg-tertiary);
      border-radius: var(--border-radius);
      padding: 1rem;
      margin-top: 1rem;
      border: 1px solid var(--border-color);
      position: relative;
    }

    .key-display::before {
      content: 'üîë';
      position: absolute;
      top: -0.5rem;
      left: 1rem;
      background: var(--bg-secondary);
      padding: 0.5rem;
      border-radius: 50%;
      font-size: 0.8rem;
    }

    .download-link {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      color: var(--text-primary);
      text-decoration: none;
      padding: 1rem 2rem;
      border-radius: var(--border-radius);
      font-weight: 600;
      transition: var(--transition-smooth);
      margin-top: 1rem;
    }

    .download-link:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-glow);
    }

    .method-params {
      background: var(--bg-tertiary);
      border-radius: var(--border-radius);
      padding: 1.5rem;
      margin-top: 1rem;
      border: 1px solid var(--border-color);
    }

    .method-selection {
      background: var(--bg-tertiary);
      border-radius: var(--border-radius);
      padding: 1.5rem;
      margin-bottom: 2rem;
      border: 1px solid var(--border-color);
      box-shadow: var(--shadow-dark);
    }

    .method-selection h3 {
      font-size: 1.2rem;
      font-weight: 600;
      margin-bottom: 1rem;
      color: var(--accent-blue);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .method-selection h3::before {
      content: '‚öôÔ∏è';
      font-size: 1.2rem;
    }

    .method-buttons {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .method-btn {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      padding: 0.8rem 1.2rem;
      border-radius: var(--border-radius);
      cursor: pointer;
      font-weight: 500;
      color: var(--text-secondary);
      transition: var(--transition-smooth);
      display: flex;
      align-items: center;
      gap: 0.8rem;
      flex: 1;
      min-width: 180px;
    }

    .method-btn:hover {
      border-color: var(--accent-primary);
      color: var(--text-primary);
      transform: translateY(-2px);
      box-shadow: var(--shadow-glow);
    }

    .method-btn.active {
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      border-color: var(--accent-primary);
      color: var(--text-primary);
      box-shadow: var(--shadow-glow);
    }

    .method-info {
      display: none; /* Hidden by default */
    }

    .method-btn:hover .method-info {
      display: block;
    }

    .method-btn {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      padding: 1.5rem;
      border-radius: var(--border-radius);
      cursor: pointer;
      font-weight: 500;
      color: var(--text-secondary);
      transition: var(--transition-smooth);
      display: flex;
      align-items: center;
      gap: 1rem;
      flex: 1;
      min-width: 200px;
      position: relative;
      overflow: hidden;
    }

    .method-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(0, 102, 255, 0.1), transparent);
      transition: var(--transition-smooth);
    }

    .method-btn:hover::before {
      left: 100%;
    }

    .method-btn span {
      font-size: 2rem;
      min-width: 2rem;
      text-align: center;
    }

    .method-info {
      flex: 1;
    }

    .method-info h4 {
      font-size: 1.1rem;
      font-weight: 600;
      margin: 0 0 0.5rem 0;
      color: var(--text-primary);
    }

    .method-info p {
      font-size: 0.9rem;
      margin: 0;
      color: var(--text-secondary);
      line-height: 1.4;
    }

    .method-btn:hover {
      border-color: var(--accent-primary);
      color: var(--text-primary);
      transform: translateY(-3px);
      box-shadow: var(--shadow-glow);
    }

    .method-btn.active {
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      border-color: var(--accent-primary);
      color: var(--text-primary);
      box-shadow: var(--shadow-glow);
    }

    .method-btn.active .method-info h4,
    .method-btn.active .method-info p {
      color: var(--text-primary);
    }

    .operation-selection {
      background: var(--bg-tertiary);
      border-radius: var(--border-radius);
      padding: 1.5rem;
      margin-bottom: 2rem;
      border: 1px solid var(--border-color);
      box-shadow: var(--shadow-dark);
    }

    .operation-selection h3 {
      font-size: 1.2rem;
      font-weight: 600;
      margin-bottom: 1rem;
      color: var(--accent-blue);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .operation-selection h3::before {
      content: 'üîÑ';
      font-size: 1.2rem;
    }

    .operation-buttons {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .operation-btn {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      padding: 0.8rem 1.2rem;
      border-radius: var(--border-radius);
      cursor: pointer;
      font-weight: 500;
      color: var(--text-secondary);
      transition: var(--transition-smooth);
      display: flex;
      align-items: center;
      gap: 0.8rem;
      flex: 1;
      min-width: 180px;
    }

    .operation-btn:hover {
      border-color: var(--accent-primary);
      color: var(--text-primary);
      transform: translateY(-2px);
      box-shadow: var(--shadow-glow);
    }

    .operation-btn.active {
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      border-color: var(--accent-primary);
      color: var(--text-primary);
      box-shadow: var(--shadow-glow);
    }

    @media (max-width: 768px) {
      .container {
        padding: 1rem;
      }

      .header h1 {
        font-size: 2rem;
      }

      .method-buttons {
        flex-direction: column;
        gap: 1rem;
      }

      .method-btn {
        min-width: auto;
        padding: 1rem;
      }

      .method-btn span {
        font-size: 1.5rem;
      }

      .operation-buttons {
        flex-direction: column;
        gap: 1rem;
      }

      .operation-btn {
        min-width: auto;
      }

      .tabs {
        flex-direction: column;
        gap: 0.5rem;
      }

      .tab-button {
        min-width: auto;
      }

      .card {
        padding: 1.5rem;
      }

      .result-display {
        padding: 1rem;
      }
    }

    .result-display {
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: var(--border-radius);
      padding: 1.5rem;
      margin-top: 1.5rem;
      animation: fadeInUp 0.3s ease-out;
    }

    .result-display h4 {
      color: var(--accent-blue);
      margin-bottom: 1rem;
      font-size: 1.2rem;
      font-weight: 600;
    }

    .result-display p {
      color: var(--text-secondary);
      margin-bottom: 1rem;
    }

    .key-display {
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: var(--border-radius);
      padding: 1rem;
      margin: 1rem 0;
    }

    .key-display label {
      color: var(--accent-blue);
      font-weight: 600;
      margin-bottom: 0.5rem;
      display: block;
    }

    .success {
      color: #4CAF50;
      background: rgba(76, 175, 80, 0.1);
      border: 1px solid rgba(76, 175, 80, 0.3);
      border-radius: var(--border-radius);
      padding: 0.75rem;
      margin: 1rem 0;
    }

    .error {
      color: #f44336;
      background: rgba(244, 67, 54, 0.1);
      border: 1px solid rgba(244, 67, 54, 0.3);
      border-radius: var(--border-radius);
      padding: 0.75rem;
      margin: 1rem 0;
    }

    .loading {
      color: var(--accent-blue);
      background: rgba(0, 102, 255, 0.1);
      border: 1px solid rgba(0, 102, 255, 0.3);
      border-radius: var(--border-radius);
      padding: 0.75rem;
      margin: 1rem 0;
    }

    /* Enhanced Security Tool Styles */
    .card-description {
      color: var(--text-secondary);
      margin-bottom: 1.5rem;
      font-style: italic;
    }

    .method-info {
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: var(--border-radius);
      padding: 1rem;
      margin: 1rem 0;
    }

    .method-details {
      display: grid;
      gap: 0.5rem;
    }

    .method-details p {
      margin: 0;
      padding: 0.25rem 0;
    }

    .method-details strong {
      color: var(--accent-primary);
      min-width: 120px;
      display: inline-block;
    }

    .integrity-result {
      padding: 1rem;
      border-radius: var(--border-radius);
      margin: 1rem 0;
    }

    .integrity-result.success {
      background: rgba(0, 255, 136, 0.1);
      border: 1px solid var(--accent-primary);
    }

    .integrity-result.error {
      background: rgba(255, 68, 68, 0.1);
      border: 1px solid #ff4444;
    }

    .integrity-result code {
      background: var(--bg-primary);
      padding: 0.5rem;
      border-radius: 4px;
      font-family: monospace;
      word-break: break-all;
      display: block;
      margin: 0.5rem 0;
    }

    /* Status styles */
    .status {
      margin-top: 1rem;
      padding: 0.75rem;
      border-radius: var(--border-radius);
      font-weight: 500;
    }

    .status.success {
      background: rgba(0, 255, 136, 0.1);
      border: 1px solid var(--accent-primary);
      color: var(--accent-primary);
    }

    .status.error {
      background: rgba(255, 68, 68, 0.1);
      border: 1px solid #ff4444;
      color: #ff4444;
    }

    .status.loading {
      background: rgba(0, 123, 255, 0.1);
      border: 1px solid #007bff;
      color: #007bff;
    }

    /* Enhanced select styling */
    optgroup {
      font-weight: bold;
      color: var(--accent-primary);
    }

    optgroup option {
      font-weight: normal;
      color: var(--text-primary);
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>Advanced Encryption & Decryption Tool</h1>
      <p>Enterprise-grade cryptography with AES-256, RSA-OAEP, and Post-Quantum Kyber</p>
    </div>

    <div class="tabs-container">
      <!-- Method Selection -->
      <div class="method-selection">
        <h3>Select Encryption Method</h3>
        <div class="method-buttons">
          <button class="method-btn" data-method="symmetric">
            <span>üîê</span>
            <div class="method-info">
              <h4>Symmetric Block Ciphers</h4>
              <p>AES, ChaCha20, Twofish, Serpent, Camellia</p>
            </div>
          </button>
          <button class="method-btn" data-method="stream">
            <span>üåä</span>
            <div class="method-info">
              <h4>Stream Ciphers</h4>
              <p>Salsa20, HC-128, Rabbit, RC4</p>
            </div>
          </button>
          <button class="method-btn" data-method="asymmetric">
            <span>üîë</span>
            <div class="method-info">
              <h4>Asymmetric Encryption</h4>
              <p>RSA, ECC, ElGamal, Paillier</p>
            </div>
          </button>
          <button class="method-btn" data-method="quantum">
            <span>‚öõÔ∏è</span>
            <div class="method-info">
              <h4>Post-Quantum</h4>
              <p>Kyber, Dilithium, Falcon, SPHINCS+</p>
            </div>
          </button>
          <button class="method-btn" data-method="hybrid">
            <span>üîÑ</span>
            <div class="method-info">
              <h4>Hybrid Encryption</h4>
              <p>RSA+AES, ECC+AES, Kyber+AES</p>
            </div>
          </button>
          <button class="method-btn" data-method="stego">
            <span>üïµÔ∏è</span>
            <div class="method-info">
              <h4>Steganography</h4>
              <p>Hide data within images</p>
            </div>
          </button>
          <button class="method-btn" data-method="security">
            <span>üõ°Ô∏è</span>
            <div class="method-info">
              <h4>Security Tools</h4>
              <p>KDF, Hashing, File Shredding</p>
            </div>
          </button>
        </div>
      </div>

      <!-- Operation Selection (shown after method selection) -->
      <div id="operation-selection" class="operation-selection" style="display: none;">
        <h3>Select Operation</h3>
        <div class="operation-buttons">
          <button class="operation-btn" data-operation="encrypt">
            <span>üîí</span> Encrypt
          </button>
          <button class="operation-btn" data-operation="decrypt">
            <span>üîì</span> Decrypt
          </button>
        </div>
      </div>

      <!-- Symmetric Block Ciphers Tabs -->
      <div id="symmetric-tabs" class="tabs" style="display: none;">
        <button class="tab-button active" data-tab="aesEnc">
          <span>üîí</span> AES Encryption
        </button>
        <button class="tab-button" data-tab="aesDec">
          <span>üîì</span> AES Decryption
        </button>
        <button class="tab-button" data-tab="chachaEnc">
          <span>üîí</span> ChaCha20
        </button>
        <button class="tab-button" data-tab="chachaDec">
          <span>üîì</span> ChaCha20 Decrypt
        </button>
        <button class="tab-button" data-tab="twofishEnc">
          <span>üîí</span> Twofish
        </button>
        <button class="tab-button" data-tab="twofishDec">
          <span>üîì</span> Twofish Decrypt
        </button>
        <button class="tab-button" data-tab="serpentEnc">
          <span>üîí</span> Serpent
        </button>
        <button class="tab-button" data-tab="serpentDec">
          <span>üîì</span> Serpent Decrypt
        </button>
        <button class="tab-button" data-tab="camelliaEnc">
          <span>üîí</span> Camellia
        </button>
        <button class="tab-button" data-tab="camelliaDec">
          <span>üîì</span> Camellia Decrypt
        </button>
      </div>

      <!-- Stream Ciphers Tabs -->
      <div id="stream-tabs" class="tabs" style="display: none;">
        <button class="tab-button active" data-tab="salsa20Enc">
          <span>üîí</span> Salsa20
        </button>
        <button class="tab-button" data-tab="salsa20Dec">
          <span>üîì</span> Salsa20 Decrypt
        </button>
        <button class="tab-button" data-tab="hc128Enc">
          <span>üîí</span> HC-128
        </button>
        <button class="tab-button" data-tab="hc128Dec">
          <span>üîì</span> HC-128 Decrypt
        </button>
        <button class="tab-button" data-tab="rabbitEnc">
          <span>üîí</span> Rabbit
        </button>
        <button class="tab-button" data-tab="rabbitDec">
          <span>üîì</span> Rabbit Decrypt
        </button>
      </div>

      <!-- Asymmetric Encryption Tabs -->
      <div id="asymmetric-tabs" class="tabs" style="display: none;">
        <button class="tab-button active" data-tab="rsaEnc">
          <span>üîí</span> RSA Encryption
        </button>
        <button class="tab-button" data-tab="rsaDec">
          <span>üîì</span> RSA Decryption
        </button>
        <button class="tab-button" data-tab="eccEnc">
          <span>üîí</span> ECC Encryption
        </button>
        <button class="tab-button" data-tab="eccDec">
          <span>üîì</span> ECC Decryption
        </button>
        <button class="tab-button" data-tab="elgamalEnc">
          <span>üîí</span> ElGamal
        </button>
        <button class="tab-button" data-tab="elgamalDec">
          <span>üîì</span> ElGamal Decrypt
        </button>
        <button class="tab-button" data-tab="paillierEnc">
          <span>üîí</span> Paillier
        </button>
        <button class="tab-button" data-tab="paillierDec">
          <span>üîì</span> Paillier Decrypt
        </button>
      </div>

      <!-- Post-Quantum Tabs -->
      <div id="quantum-tabs" class="tabs" style="display: none;">
        <button class="tab-button active" data-tab="kyberEnc">
          <span>üîí</span> Kyber KEM
        </button>
        <button class="tab-button" data-tab="kyberDec">
          <span>üîì</span> Kyber Decaps
        </button>
        <button class="tab-button" data-tab="dilithiumSign">
          <span>‚úçÔ∏è</span> Dilithium Sign
        </button>
        <button class="tab-button" data-tab="dilithiumVerify">
          <span>‚úÖ</span> Dilithium Verify
        </button>
        <button class="tab-button" data-tab="falconSign">
          <span>‚úçÔ∏è</span> Falcon Sign
        </button>
        <button class="tab-button" data-tab="falconVerify">
          <span>‚úÖ</span> Falcon Verify
        </button>
        <button class="tab-button" data-tab="sphincsSign">
          <span>‚úçÔ∏è</span> SPHINCS+ Sign
        </button>
        <button class="tab-button" data-tab="sphincsVerify">
          <span>‚úÖ</span> SPHINCS+ Verify
        </button>
      </div>

      <!-- Hybrid Encryption Tabs -->
      <div id="hybrid-tabs" class="tabs" style="display: none;">
        <button class="tab-button active" data-tab="rsaAesEnc">
          <span>üîí</span> RSA+AES Hybrid
        </button>
        <button class="tab-button" data-tab="rsaAesDec">
          <span>üîì</span> RSA+AES Decrypt
        </button>
        <button class="tab-button" data-tab="eccAesEnc">
          <span>üîí</span> ECC+AES Hybrid
        </button>
        <button class="tab-button" data-tab="eccAesDec">
          <span>üîì</span> ECC+AES Decrypt
        </button>
        <button class="tab-button" data-tab="kyberAesEnc">
          <span>üîí</span> Kyber+AES Hybrid
        </button>
        <button class="tab-button" data-tab="kyberAesDec">
          <span>üîì</span> Kyber+AES Decrypt
        </button>
        <button class="tab-button" data-tab="doubleHybridEnc">
          <span>üîí</span> Double Hybrid
        </button>
        <button class="tab-button" data-tab="doubleHybridDec">
          <span>üîì</span> Double Hybrid Decrypt
        </button>
      </div>

      <!-- Steganography Tabs -->
      <div id="stego-tabs" class="tabs" style="display: none;">
        <button class="tab-button active" data-tab="stegoEnc">
          <span>üîí</span> Hide Data
        </button>
        <button class="tab-button" data-tab="stegoDec">
          <span>üîì</span> Extract Data
        </button>
      </div>

      <!-- Security Tools Tabs -->
      <div id="security-tabs" class="tabs" style="display: none;">
        <button class="tab-button active" data-tab="kdf">
          <span>üîë</span> Key Derivation
        </button>
        <button class="tab-button" data-tab="hash">
          <span>üìã</span> Hashing
        </button>
        <button class="tab-button" data-tab="shred">
          <span>üóëÔ∏è</span> File Shredding
        </button>
        <button class="tab-button" data-tab="integrity">
          <span>‚úÖ</span> Integrity Check
        </button>
      </div>
    </div>

  <!-- AES ENCRYPTION -->
  <div id="aesEnc" class="tab active">
    <div class="card">
      <h3>AES Encryption</h3>
      
      <div class="form-group">
        <label>
          Plaintext
          <button class="info-btn" onclick="showInfo('plaintext')">‚Ñπ</button>
        </label>
        <textarea id="aesPlaintext" class="form-control" rows="6" placeholder="Enter the text you want to encrypt..."></textarea>
      </div>

      <div class="form-group">
        <label>
          AES Key Size
          <button class="info-btn" onclick="showInfo('aesKeySize')">‚Ñπ</button>
        </label>
        <select id="aesKeySize" class="form-control">
          <option value="128">AES-128 (Faster)</option>
          <option value="192">AES-192 (Balanced)</option>
          <option value="256" selected>AES-256 (Recommended)</option>
        </select>
      </div>

      <div class="form-group">
        <label>
          Encryption Mode
          <button class="info-btn" onclick="showInfo('aesMode')">‚Ñπ</button>
        </label>
        <select id="aesMode" class="form-control">
          <option value="GCM" selected>AES-GCM (Authenticated)</option>
          <option value="CBC">AES-CBC (Standard)</option>
          <option value="CTR">AES-CTR (Fast)</option>
          <option value="CCM">AES-CCM (Constrained)</option>
        </select>
      </div>
      
      <div class="form-group">
        <label>Passphrase</label>
        <input type="password" id="aesKey" class="form-control" placeholder="Enter a strong passphrase...">
      </div>
      
      <button class="btn btn-primary" onclick="encryptAES()">
        <span>üîí</span> Encrypt Text
      </button>
      
      <div id="aesEncResult" class="result-display" style="display: none;">
        <h4>Encrypted Result</h4>
        <textarea id="aesEncryptedText" class="form-control" rows="4" readonly></textarea>
        <button class="btn btn-secondary" onclick="copyToClipboard('aesEncryptedText')">
          <span>üìã</span> Copy
        </button>
      </div>
    </div>
  </div>

  <!-- AES DECRYPTION -->
  <div id="aesDec" class="tab">
    <div class="card">
      <h3>AES Decryption</h3>
      
      <div class="form-group">
        <label>
          Encrypted Text
          <button class="info-btn" onclick="showInfo('encryptedText')">‚Ñπ</button>
        </label>
        <textarea id="aesEncryptedInput" class="form-control" rows="6" placeholder="Enter the encrypted text..."></textarea>
      </div>

      <div class="form-group">
        <label>
          Encryption Mode
          <button class="info-btn" onclick="showInfo('aesMode')">‚Ñπ</button>
        </label>
        <select id="aesDecMode" class="form-control">
          <option value="GCM" selected>AES-GCM (Authenticated)</option>
          <option value="CBC">AES-CBC (Standard)</option>
          <option value="CTR">AES-CTR (Fast)</option>
          <option value="CCM">AES-CCM (Constrained)</option>
        </select>
      </div>

      <div class="form-group">
        <label>Passphrase</label>
        <input type="password" id="aesDecKey" class="form-control" placeholder="Enter the passphrase used for encryption...">
      </div>
      
      <button class="btn btn-primary" onclick="decryptAES()">
        <span>üîì</span> Decrypt Text
      </button>
      
      <div id="aesDecResult" class="result-display" style="display: none;">
        <h4>Decrypted Result</h4>
        <textarea id="aesDecryptedText" class="form-control" rows="4" readonly></textarea>
        <button class="btn btn-secondary" onclick="copyToClipboard('aesDecryptedText')">
          <span>üìã</span> Copy
        </button>
      </div>
    </div>
  </div>

  <!-- CHACHA20 ENCRYPTION -->
  <div id="chachaEnc" class="tab">
    <div class="card">
      <h3>ChaCha20 Encryption</h3>
      
      <div class="form-group">
        <label>
          Plaintext
          <button class="info-btn" onclick="showInfo('plaintext')">‚Ñπ</button>
        </label>
        <textarea id="chachaPlaintext" class="form-control" rows="6" placeholder="Enter the text you want to encrypt..."></textarea>
      </div>

      <div class="form-group">
        <label>
          ChaCha20 Variant
          <button class="info-btn" onclick="showInfo('chachaVariant')">‚Ñπ</button>
        </label>
        <select id="chachaVariant" class="form-control">
          <option value="ChaCha20" selected>ChaCha20 (Stream Cipher)</option>
          <option value="ChaCha20-Poly1305">ChaCha20-Poly1305 (AEAD)</option>
        </select>
      </div>
      
      <div class="form-group">
        <label>Passphrase</label>
        <input type="password" id="chachaKey" class="form-control" placeholder="Enter a strong passphrase...">
      </div>
      
      <button class="btn btn-primary" onclick="encryptChaCha20()">
        <span>üîí</span> Encrypt Text
      </button>
      
      <div id="chachaEncResult" class="result-display" style="display: none;">
        <h4>Encrypted Result</h4>
        <textarea id="chachaEncryptedText" class="form-control" rows="4" readonly></textarea>
        <button class="btn btn-secondary" onclick="copyToClipboard('chachaEncryptedText')">
          <span>üìã</span> Copy
        </button>
      </div>
    </div>
  </div>

  <!-- CHACHA20 DECRYPTION -->
  <div id="chachaDec" class="tab">
    <div class="card">
      <h3>ChaCha20 Decryption</h3>
      
      <div class="form-group">
        <label>
          Encrypted Text
          <button class="info-btn" onclick="showInfo('encryptedText')">‚Ñπ</button>
        </label>
        <textarea id="chachaEncryptedInput" class="form-control" rows="6" placeholder="Enter the encrypted text..."></textarea>
      </div>

      <div class="form-group">
        <label>
          ChaCha20 Variant
          <button class="info-btn" onclick="showInfo('chachaVariant')">‚Ñπ</button>
        </label>
        <select id="chachaDecVariant" class="form-control">
          <option value="ChaCha20" selected>ChaCha20 (Stream Cipher)</option>
          <option value="ChaCha20-Poly1305">ChaCha20-Poly1305 (AEAD)</option>
        </select>
      </div>

      <div class="form-group">
        <label>Passphrase</label>
        <input type="password" id="chachaDecKey" class="form-control" placeholder="Enter the passphrase used for encryption...">
      </div>
      
      <button class="btn btn-primary" onclick="decryptChaCha20()">
        <span>üîì</span> Decrypt Text
      </button>
      
      <div id="chachaDecResult" class="result-display" style="display: none;">
        <h4>Decrypted Result</h4>
        <textarea id="chachaDecryptedText" class="form-control" rows="4" readonly></textarea>
        <button class="btn btn-secondary" onclick="copyToClipboard('chachaDecryptedText')">
          <span>üìã</span> Copy
        </button>
      </div>
    </div>
  </div>

  <!-- TWOFISH ENCRYPTION -->
  <div id="twofishEnc" class="tab">
    <div class="card">
      <h3>Twofish Encryption</h3>
      
      <div class="form-group">
        <label>
          Plaintext
          <button class="info-btn" onclick="showInfo('plaintext')">‚Ñπ</button>
        </label>
        <textarea id="twofishPlaintext" class="form-control" rows="6" placeholder="Enter the text you want to encrypt..."></textarea>
      </div>

      <div class="form-group">
        <label>
          Key Size
          <button class="info-btn" onclick="showInfo('twofishKeySize')">‚Ñπ</button>
        </label>
        <select id="twofishKeySize" class="form-control">
          <option value="128">128-bit</option>
          <option value="192">192-bit</option>
          <option value="256" selected>256-bit (Recommended)</option>
        </select>
      </div>
      
      <div class="form-group">
        <label>Passphrase</label>
        <input type="password" id="twofishKey" class="form-control" placeholder="Enter a strong passphrase...">
      </div>
      
      <button class="btn btn-primary" onclick="encryptTwofish()">
        <span>üîí</span> Encrypt Text
      </button>
      
      <div id="twofishEncResult" class="result-display" style="display: none;">
        <h4>Encrypted Result</h4>
        <textarea id="twofishEncryptedText" class="form-control" rows="4" readonly></textarea>
        <button class="btn btn-secondary" onclick="copyToClipboard('twofishEncryptedText')">
          <span>üìã</span> Copy
        </button>
      </div>
    </div>
  </div>

  <!-- TWOFISH DECRYPTION -->
  <div id="twofishDec" class="tab">
    <div class="card">
      <h3>Twofish Decryption</h3>
      
      <div class="form-group">
        <label>
          Encrypted Text
          <button class="info-btn" onclick="showInfo('encryptedText')">‚Ñπ</button>
        </label>
        <textarea id="twofishEncryptedInput" class="form-control" rows="6" placeholder="Enter the encrypted text..."></textarea>
      </div>

      <div class="form-group">
        <label>Passphrase</label>
        <input type="password" id="twofishDecKey" class="form-control" placeholder="Enter the passphrase used for encryption...">
      </div>
      
      <button class="btn btn-primary" onclick="decryptTwofish()">
        <span>üîì</span> Decrypt Text
      </button>
      
      <div id="twofishDecResult" class="result-display" style="display: none;">
        <h4>Decrypted Result</h4>
        <textarea id="twofishDecryptedText" class="form-control" rows="4" readonly></textarea>
        <button class="btn btn-secondary" onclick="copyToClipboard('twofishDecryptedText')">
          <span>üìã</span> Copy
        </button>
      </div>
    </div>
  </div>

  <!-- SERPENT ENCRYPTION -->
  <div id="serpentEnc" class="tab">
    <div class="card">
      <h3>Serpent Encryption</h3>
      
      <div class="form-group">
        <label>
          Plaintext
          <button class="info-btn" onclick="showInfo('plaintext')">‚Ñπ</button>
        </label>
        <textarea id="serpentPlaintext" class="form-control" rows="6" placeholder="Enter the text you want to encrypt..."></textarea>
      </div>

      <div class="form-group">
        <label>
          Key Size
          <button class="info-btn" onclick="showInfo('serpentKeySize')">‚Ñπ</button>
        </label>
        <select id="serpentKeySize" class="form-control">
          <option value="128">128-bit</option>
          <option value="192">192-bit</option>
          <option value="256" selected>256-bit (Recommended)</option>
        </select>
      </div>
      
      <div class="form-group">
        <label>Passphrase</label>
        <input type="password" id="serpentKey" class="form-control" placeholder="Enter a strong passphrase...">
      </div>
      
      <button class="btn btn-primary" onclick="encryptSerpent()">
        <span>üîí</span> Encrypt Text
      </button>
      
      <div id="serpentEncResult" class="result-display" style="display: none;">
        <h4>Encrypted Result</h4>
        <textarea id="serpentEncryptedText" class="form-control" rows="4" readonly></textarea>
        <button class="btn btn-secondary" onclick="copyToClipboard('serpentEncryptedText')">
          <span>üìã</span> Copy
        </button>
      </div>
    </div>
  </div>

  <!-- SERPENT DECRYPTION -->
  <div id="serpentDec" class="tab">
    <div class="card">
      <h3>Serpent Decryption</h3>
      
      <div class="form-group">
        <label>
          Encrypted Text
          <button class="info-btn" onclick="showInfo('encryptedText')">‚Ñπ</button>
        </label>
        <textarea id="serpentEncryptedInput" class="form-control" rows="6" placeholder="Enter the encrypted text..."></textarea>
      </div>

      <div class="form-group">
        <label>Passphrase</label>
        <input type="password" id="serpentDecKey" class="form-control" placeholder="Enter the passphrase used for encryption...">
      </div>
      
      <button class="btn btn-primary" onclick="decryptSerpent()">
        <span>üîì</span> Decrypt Text
      </button>
      
      <div id="serpentDecResult" class="result-display" style="display: none;">
        <h4>Decrypted Result</h4>
        <textarea id="serpentDecryptedText" class="form-control" rows="4" readonly></textarea>
        <button class="btn btn-secondary" onclick="copyToClipboard('serpentDecryptedText')">
          <span>üìã</span> Copy
        </button>
      </div>
    </div>
  </div>

  <!-- CAMELLIA ENCRYPTION -->
  <div id="camelliaEnc" class="tab">
    <div class="card">
      <h3>Camellia Encryption</h3>
      
      <div class="form-group">
        <label>
          Plaintext
          <button class="info-btn" onclick="showInfo('plaintext')">‚Ñπ</button>
        </label>
        <textarea id="camelliaPlaintext" class="form-control" rows="6" placeholder="Enter the text you want to encrypt..."></textarea>
      </div>

      <div class="form-group">
        <label>
          Key Size
          <button class="info-btn" onclick="showInfo('camelliaKeySize')">‚Ñπ</button>
        </label>
        <select id="camelliaKeySize" class="form-control">
          <option value="128">128-bit</option>
          <option value="192">192-bit</option>
          <option value="256" selected>256-bit (Recommended)</option>
        </select>
      </div>
      
      <div class="form-group">
        <label>Passphrase</label>
        <input type="password" id="camelliaKey" class="form-control" placeholder="Enter a strong passphrase...">
      </div>
      
      <button class="btn btn-primary" onclick="encryptCamellia()">
        <span>üîí</span> Encrypt Text
      </button>
      
      <div id="camelliaEncResult" class="result-display" style="display: none;">
        <h4>Encrypted Result</h4>
        <textarea id="camelliaEncryptedText" class="form-control" rows="4" readonly></textarea>
        <button class="btn btn-secondary" onclick="copyToClipboard('camelliaEncryptedText')">
          <span>üìã</span> Copy
        </button>
      </div>
    </div>
  </div>

  <!-- CAMELLIA DECRYPTION -->
  <div id="camelliaDec" class="tab">
    <div class="card">
      <h3>Camellia Decryption</h3>
      
      <div class="form-group">
        <label>
          Encrypted Text
          <button class="info-btn" onclick="showInfo('encryptedText')">‚Ñπ</button>
        </label>
        <textarea id="camelliaEncryptedInput" class="form-control" rows="6" placeholder="Enter the encrypted text..."></textarea>
      </div>

      <div class="form-group">
        <label>Passphrase</label>
        <input type="password" id="camelliaDecKey" class="form-control" placeholder="Enter the passphrase used for encryption...">
      </div>
      
      <button class="btn btn-primary" onclick="decryptCamellia()">
        <span>üîì</span> Decrypt Text
      </button>
      
      <div id="camelliaDecResult" class="result-display" style="display: none;">
        <h4>Decrypted Result</h4>
        <textarea id="camelliaDecryptedText" class="form-control" rows="4" readonly></textarea>
        <button class="btn btn-secondary" onclick="copyToClipboard('camelliaDecryptedText')">
          <span>üìã</span> Copy
        </button>
      </div>
    </div>
  </div>

  </div>

  <!-- SECURITY TOOLS TABS -->
  
  <!-- Key Derivation Tab -->
  <div id="kdf" class="tab">
    <div class="card">
      <h3>Key Derivation Functions</h3>
      
      <div class="form-group">
        <label>Password</label>
        <input type="password" id="kdfPassword" class="form-control" placeholder="Enter password...">
      </div>
      
      <div class="form-group">
        <label>Salt (Base64)</label>
        <input type="text" id="kdfSalt" class="form-control" placeholder="Leave empty for random salt">
      </div>
      
      <div class="form-group">
        <label>Algorithm</label>
        <select id="kdfAlgorithm" class="form-control">
          <option value="pbkdf2">PBKDF2 (SHA-256)</option>
          <option value="argon2id">Argon2id (PBKDF2 fallback)</option>
          <option value="scrypt">Scrypt (PBKDF2 fallback)</option>
        </select>
      </div>
      
      <button class="btn btn-primary" onclick="deriveKey()">
        <span>üîë</span> Derive Key
      </button>
      
      <div id="kdfResultDisplay" class="result-display" style="display: none;">
        <h4>Derived Key</h4>
        <textarea id="kdfResult" class="form-control" rows="4" readonly></textarea>
        <button class="btn btn-secondary" onclick="copyToClipboard('kdfResult')">
          <span>üìã</span> Copy
        </button>
      </div>
      
      <div id="kdfStatus" class="status"></div>
    </div>
  </div>

  <!-- Hashing Tab -->
  <div id="hash" class="tab">
    <div class="card">
      <h3>Hash Functions</h3>
      
      <div class="form-group">
        <label>Input Data</label>
        <textarea id="hashInput" class="form-control" rows="6" placeholder="Enter data to hash..."></textarea>
      </div>
      
      <div class="form-group">
        <label>Hash Algorithm</label>
        <select id="hashAlgorithm" class="form-control">
          <option value="sha256">SHA-256</option>
          <option value="sha512">SHA-512</option>
          <option value="sha3_256">SHA-3-256</option>
          <option value="sha3_512">SHA-3-512</option>
          <option value="blake2b">BLAKE2b (SHA-256 fallback)</option>
          <option value="blake3">BLAKE3 (SHA-256 fallback)</option>
        </select>
      </div>
      
      <button class="btn btn-primary" onclick="hashData()">
        <span>üìã</span> Hash Data
      </button>
      
      <div id="hashResultDisplay" class="result-display" style="display: none;">
        <h4>Hash Result</h4>
        <textarea id="hashResult" class="form-control" rows="4" readonly></textarea>
        <button class="btn btn-secondary" onclick="copyToClipboard('hashResult')">
          <span>üìã</span> Copy
        </button>
      </div>
      
      <div id="hashStatus" class="status"></div>
    </div>
  </div>

  <!-- File Shredding Tab -->
  <div id="shred" class="tab">
    <div class="card">
      <h3>üóëÔ∏è Enhanced File Shredding</h3>
      <p class="card-description">Secure file deletion using industry-standard methods</p>
      
      <div class="form-group">
        <label>Select File to Shred</label>
        <input type="file" id="shredFileInput" class="form-control">
      </div>
      
      <div class="form-group">
        <label>Shredding Method</label>
        <select id="shredMethod" class="form-control">
          <optgroup label="1Ô∏è‚É£ 1-Pass Methods (Fast, SSD-Friendly)">
            <option value="zero-fill">Zero Fill (0x00) - Overwrite with zeros once</option>
            <option value="random-fill">Random Fill - Overwrite with random data once</option>
            <option value="protectstar-1pass">ProtectStar 1-pass - Single-pass optimized random fill</option>
          </optgroup>
          <optgroup label="2Ô∏è‚É£ 3-Pass Methods (Standard Secure)">
            <option value="dod-522022m">DoD 5220.22-M (3-pass) - 0x00, 0xFF, Random</option>
            <option value="hmg-is5">HMG IS5 / NCSC-TG-025 (UK) - 0, 1, Random</option>
            <option value="navso-p523926">NAVSO P-5239-26 (US Navy) - Random, Complement, Random</option>
          </optgroup>
          <optgroup label="3Ô∏è‚É£ 7-Pass Methods (Extended Secure for HDDs)">
            <option value="dod-extended">DoD 5220.22-M Extended (7-pass) - 0/1/random pattern sequence</option>
            <option value="vsitr">VSITR (Germany) - Alternating 0/1, final pass random</option>
          </optgroup>
          <optgroup label="4Ô∏è‚É£ 35-Pass (Legacy Maximum for HDDs)">
            <option value="gutmann">Gutmann (35-pass) - Mix of random + historical magnetic patterns</option>
          </optgroup>
          <optgroup label="5Ô∏è‚É£ 50-Pass Extreme (Overkill)">
            <option value="protectstar-50">ProtectStar 50-pass - Proprietary random/pattern mix</option>
          </optgroup>
          <optgroup label="6Ô∏è‚É£ Cryptographic / Logical Wipe">
            <option value="cryptographic-erase">Cryptographic Erase - Encrypt then delete key (Recommended)</option>
          </optgroup>
        </select>
      </div>
      
      <div class="method-info" id="methodInfo" style="display: none;">
        <h4>Method Information</h4>
        <div id="methodDetails"></div>
      </div>
      
      <button class="btn btn-primary" onclick="shredFile()">
        <span>üóëÔ∏è</span> Shred File
      </button>
      
      <div id="shredResult" class="result-display" style="display: none;">
        <h4>Shredded File</h4>
        <p>Your file has been securely shredded. Download the shredded version:</p>
        <a id="downloadShreddedFile" class="btn btn-secondary" download>
          <span>üì•</span> Download Shredded File
        </a>
      </div>
      
      <div id="shredStatus" class="status"></div>
    </div>
  </div>

  <!-- Integrity Check Tab -->
  <div id="integrity" class="tab">
    <div class="card">
      <h3>‚úÖ File Integrity Check</h3>
      
      <div class="form-group">
        <label>Original File</label>
        <input type="file" id="integrityOriginal" class="form-control">
      </div>
      
      <div class="form-group">
        <label>File to Verify</label>
        <input type="file" id="integrityVerify" class="form-control">
      </div>
      
      <div class="form-group">
        <label>Hash Algorithm</label>
        <select id="integrityAlgorithm" class="form-control">
          <option value="sha256">SHA-256</option>
          <option value="sha512">SHA-512</option>
          <option value="sha3_256">SHA-3-256</option>
        </select>
      </div>
      
      <button class="btn btn-primary" onclick="checkIntegrity()">
        <span>‚úÖ</span> Check Integrity
      </button>
      
      <div id="integrityResult" class="result-display" style="display: none;">
        <h4>Integrity Check Result</h4>
        <div id="integrityDetails"></div>
      </div>
      
      <div id="integrityStatus" class="status"></div>
    </div>
  </div>

  <!-- Info Popup -->
  <div class="overlay" id="overlay" onclick="hideInfo()"></div>
  <div class="popup" id="popup">
    <button class="popup-close" onclick="hideInfo()">√ó</button>
    <div id="popupContent"></div>
  </div>

  <script>
    // Global variables
    let OQS_Module = null;
    let selectedMethod = null;
    let selectedOperation = null;

    // Initialize OQS (Open Quantum Safe) library
    async function initializeOQS() {
      try {
        if (typeof OQS !== 'undefined') {
          OQS_Module = await OQS();
          console.log('OQS library initialized successfully');
        }
      } catch (error) {
        console.error('Failed to initialize OQS library:', error);
      }
    }

    // Utility functions
    function toB64(arr) {
      return btoa(String.fromCharCode(...new Uint8Array(arr)));
    }

    function fromB64(str) {
      return new Uint8Array(atob(str).split('').map(c => c.charCodeAt(0)));
    }

    function concat(...arrays) {
      const totalLength = arrays.reduce((acc, arr) => acc + arr.byteLength, 0);
      const result = new Uint8Array(totalLength);
      let offset = 0;
      for (const arr of arrays) {
        result.set(new Uint8Array(arr), offset);
        offset += arr.byteLength;
      }
      return result;
    }

    // Key Derivation Function (Argon2id-like using PBKDF2)
    async function derive(password, salt, keyLength) {
      const enc = new TextEncoder();
      const keyMaterial = await crypto.subtle.importKey(
        'raw',
        enc.encode(password),
        'PBKDF2',
        false,
        ['deriveBits']
      );
      return await crypto.subtle.deriveBits(
        {
          name: 'PBKDF2',
          salt: salt,
          iterations: 100000,
          hash: 'SHA-256'
        },
        keyMaterial,
        keyLength
      );
    }

    // AES Implementation (Web Crypto API)
    class AESEncryption {
      static async encrypt(data, key, mode = 'GCM', iv = null) {
        const enc = new TextEncoder();
        const keyData = await crypto.subtle.importKey(
          'raw',
          key,
          { name: 'AES-GCM' },
          false,
          ['encrypt']
        );
        
        if (!iv) iv = crypto.getRandomValues(new Uint8Array(12));
        
        const encrypted = await crypto.subtle.encrypt(
          { name: 'AES-GCM', iv: iv },
          keyData,
          enc.encode(data)
        );
        
        return {
          ciphertext: new Uint8Array(encrypted),
          iv: iv,
          mode: mode
        };
      }

      static async decrypt(ciphertext, key, iv, mode = 'GCM') {
        const keyData = await crypto.subtle.importKey(
          'raw',
          key,
          { name: 'AES-GCM' },
          false,
          ['decrypt']
        );
        
        const decrypted = await crypto.subtle.decrypt(
          { name: 'AES-GCM', iv: iv },
          keyData,
          ciphertext
        );
        
        return new TextDecoder().decode(decrypted);
      }
    }

    // ChaCha20 Implementation (using Web Crypto API)
    class ChaCha20Encryption {
      static async encrypt(data, key, nonce = null) {
        const enc = new TextEncoder();
        if (!nonce) nonce = crypto.getRandomValues(new Uint8Array(12));
        
        const keyData = await crypto.subtle.importKey(
          'raw',
          key,
          { name: 'ChaCha20-Poly1305' },
          false,
          ['encrypt']
        );
        
        const encrypted = await crypto.subtle.encrypt(
          { name: 'ChaCha20-Poly1305', nonce: nonce },
          keyData,
          enc.encode(data)
        );
        
        return {
          ciphertext: new Uint8Array(encrypted),
          nonce: nonce
        };
      }

      static async decrypt(ciphertext, key, nonce) {
        const keyData = await crypto.subtle.importKey(
          'raw',
          key,
          { name: 'ChaCha20-Poly1305' },
          false,
          ['decrypt']
        );
        
        const decrypted = await crypto.subtle.decrypt(
          { name: 'ChaCha20-Poly1305', nonce: nonce },
          keyData,
          ciphertext
        );
        
        return new TextDecoder().decode(decrypted);
      }
    }

    // Twofish Implementation (Simplified - using AES as fallback)
    class TwofishEncryption {
      static async encrypt(data, key) {
        // Note: Twofish is not available in Web Crypto API
        // Using AES-256 as a secure alternative
        console.warn('Twofish not available in Web Crypto API, using AES-256');
        return await AESEncryption.encrypt(data, key, 'GCM');
      }

      static async decrypt(ciphertext, key, iv) {
        console.warn('Twofish not available in Web Crypto API, using AES-256');
        return await AESEncryption.decrypt(ciphertext, key, iv, 'GCM');
      }
    }

    // Serpent Implementation (Simplified - using AES as fallback)
    class SerpentEncryption {
      static async encrypt(data, key) {
        // Note: Serpent is not available in Web Crypto API
        // Using AES-256 as a secure alternative
        console.warn('Serpent not available in Web Crypto API, using AES-256');
        return await AESEncryption.encrypt(data, key, 'GCM');
      }

      static async decrypt(ciphertext, key, iv) {
        console.warn('Serpent not available in Web Crypto API, using AES-256');
        return await AESEncryption.decrypt(ciphertext, key, iv, 'GCM');
      }
    }

    // Camellia Implementation (Simplified - using AES as fallback)
    class CamelliaEncryption {
      static async encrypt(data, key) {
        // Note: Camellia is not available in Web Crypto API
        // Using AES-256 as a secure alternative
        console.warn('Camellia not available in Web Crypto API, using AES-256');
        return await AESEncryption.encrypt(data, key, 'GCM');
      }

      static async decrypt(ciphertext, key, iv) {
        console.warn('Camellia not available in Web Crypto API, using AES-256');
        return await AESEncryption.decrypt(ciphertext, key, iv, 'GCM');
      }
    }

    // Salsa20 Implementation (using ChaCha20 as it's closely related)
    class Salsa20Encryption {
      static async encrypt(data, key, nonce = null) {
        // Salsa20 is closely related to ChaCha20
        return await ChaCha20Encryption.encrypt(data, key, nonce);
      }

      static async decrypt(ciphertext, key, nonce) {
        return await ChaCha20Encryption.decrypt(ciphertext, key, nonce);
      }
    }

    // HC-128 Implementation (Simplified - using ChaCha20 as fallback)
    class HC128Encryption {
      static async encrypt(data, key, nonce = null) {
        // Note: HC-128 is not available in Web Crypto API
        // Using ChaCha20 as a secure alternative
        console.warn('HC-128 not available in Web Crypto API, using ChaCha20');
        return await ChaCha20Encryption.encrypt(data, key, nonce);
      }

      static async decrypt(ciphertext, key, nonce) {
        console.warn('HC-128 not available in Web Crypto API, using ChaCha20');
        return await ChaCha20Encryption.decrypt(ciphertext, key, nonce);
      }
    }

    // Rabbit Implementation (Simplified - using ChaCha20 as fallback)
    class RabbitEncryption {
      static async encrypt(data, key, nonce = null) {
        // Note: Rabbit is not available in Web Crypto API
        // Using ChaCha20 as a secure alternative
        console.warn('Rabbit not available in Web Crypto API, using ChaCha20');
        return await ChaCha20Encryption.encrypt(data, key, nonce);
      }

      static async decrypt(ciphertext, key, nonce) {
        console.warn('Rabbit not available in Web Crypto API, using ChaCha20');
        return await ChaCha20Encryption.decrypt(ciphertext, key, nonce);
      }
    }

    // RSA Implementation (Web Crypto API)
    class RSAEncryption {
      static async generateKeyPair(keySize = 2048) {
        return await crypto.subtle.generateKey(
          {
            name: 'RSA-OAEP',
            modulusLength: keySize,
            publicExponent: new Uint8Array([1, 0, 1]),
            hash: 'SHA-256'
          },
          true,
          ['encrypt', 'decrypt']
        );
      }

      static async encrypt(data, publicKey) {
        const enc = new TextEncoder();
        const encrypted = await crypto.subtle.encrypt(
          { name: 'RSA-OAEP' },
          publicKey,
          enc.encode(data)
        );
        return new Uint8Array(encrypted);
      }

      static async decrypt(ciphertext, privateKey) {
        const decrypted = await crypto.subtle.decrypt(
          { name: 'RSA-OAEP' },
          privateKey,
          ciphertext
        );
        return new TextDecoder().decode(decrypted);
      }

      static async exportPublicKey(publicKey) {
        const exported = await crypto.subtle.exportKey('spki', publicKey);
        return toB64(exported);
      }

      static async exportPrivateKey(privateKey) {
        const exported = await crypto.subtle.exportKey('pkcs8', privateKey);
        return toB64(exported);
      }

      static async importPublicKey(keyData) {
        const key = await crypto.subtle.importKey(
          'spki',
          fromB64(keyData),
          { name: 'RSA-OAEP', hash: 'SHA-256' },
          false,
          ['encrypt']
        );
        return key;
      }

      static async importPrivateKey(keyData) {
        const key = await crypto.subtle.importKey(
          'pkcs8',
          fromB64(keyData),
          { name: 'RSA-OAEP', hash: 'SHA-256' },
          false,
          ['decrypt']
        );
        return key;
      }
    }

    // ECC Implementation (Web Crypto API)
    class ECCEncryption {
      static async generateKeyPair(curve = 'P-256') {
        return await crypto.subtle.generateKey(
          {
            name: 'ECDH',
            namedCurve: curve
          },
          true,
          ['deriveKey', 'deriveBits']
        );
      }

      static async deriveSharedSecret(privateKey, publicKey) {
        return await crypto.subtle.deriveBits(
          {
            name: 'ECDH',
            public: publicKey
          },
          privateKey,
          256
        );
      }

      static async exportPublicKey(publicKey) {
        const exported = await crypto.subtle.exportKey('spki', publicKey);
        return toB64(exported);
      }

      static async exportPrivateKey(privateKey) {
        const exported = await crypto.subtle.exportKey('pkcs8', privateKey);
        return toB64(exported);
      }

      static async importPublicKey(keyData, curve = 'P-256') {
        const key = await crypto.subtle.importKey(
          'spki',
          fromB64(keyData),
          { name: 'ECDH', namedCurve: curve },
          false,
          ['deriveKey', 'deriveBits']
        );
        return key;
      }

      static async importPrivateKey(keyData, curve = 'P-256') {
        const key = await crypto.subtle.importKey(
          'pkcs8',
          fromB64(keyData),
          { name: 'ECDH', namedCurve: curve },
          false,
          ['deriveKey', 'deriveBits']
        );
        return key;
      }
    }

    // ElGamal Implementation (Simplified - using ECC as fallback)
    class ElGamalEncryption {
      static async generateKeyPair(curve = 'P-256') {
        return await ECCEncryption.generateKeyPair(curve);
      }

      static async encrypt(data, publicKey) {
        // ElGamal encryption using ECC
        const ephemeralKeyPair = await ECCEncryption.generateKeyPair();
        const sharedSecret = await ECCEncryption.deriveSharedSecret(ephemeralKeyPair.privateKey, publicKey);
        
        // Use shared secret to derive AES key
        const aesKey = await crypto.subtle.importKey(
          'raw',
          sharedSecret,
          { name: 'AES-GCM' },
          false,
          ['encrypt']
        );
        
        const enc = new TextEncoder();
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const encrypted = await crypto.subtle.encrypt(
          { name: 'AES-GCM', iv: iv },
          aesKey,
          enc.encode(data)
        );
        
        const ephemeralPublicKey = await ECCEncryption.exportPublicKey(ephemeralKeyPair.publicKey);
        
        return {
          ciphertext: new Uint8Array(encrypted),
          ephemeralPublicKey: ephemeralPublicKey,
          iv: iv
        };
      }

      static async decrypt(encryptedData, privateKey) {
        const ephemeralPublicKey = await ECCEncryption.importPublicKey(encryptedData.ephemeralPublicKey);
        const sharedSecret = await ECCEncryption.deriveSharedSecret(privateKey, ephemeralPublicKey);
        
        const aesKey = await crypto.subtle.importKey(
          'raw',
          sharedSecret,
          { name: 'AES-GCM' },
          false,
          ['decrypt']
        );
        
        const decrypted = await crypto.subtle.decrypt(
          { name: 'AES-GCM', iv: encryptedData.iv },
          aesKey,
          encryptedData.ciphertext
        );
        
        return new TextDecoder().decode(decrypted);
      }
    }

    // Paillier Implementation (Simplified - using RSA as fallback)
    class PaillierEncryption {
      static async generateKeyPair(keySize = 2048) {
        return await RSAEncryption.generateKeyPair(keySize);
      }

      static async encrypt(data, publicKey) {
        // Simplified Paillier using RSA
        console.warn('Full Paillier not available, using RSA-OAEP');
        return await RSAEncryption.encrypt(data, publicKey);
      }

      static async decrypt(ciphertext, privateKey) {
        console.warn('Full Paillier not available, using RSA-OAEP');
        return await RSAEncryption.decrypt(ciphertext, privateKey);
      }
    }

    // Kyber Implementation (using OQS library)
    class KyberEncryption {
      static async generateKeyPair(variant = 'Kyber768') {
        if (!OQS_Module) {
          throw new Error('OQS library not initialized');
        }
        
        const kem = new OQS_Module.KEM(variant);
        const keypair = kem.keypair();
        
        return {
          publicKey: toB64(keypair.publicKey),
          privateKey: toB64(keypair.secretKey),
          variant: variant
        };
      }

      static async encrypt(data, publicKey, variant = 'Kyber768') {
        if (!OQS_Module) {
          throw new Error('OQS library not initialized');
        }
        
        const kem = new OQS_Module.KEM(variant);
        const pubKey = fromB64(publicKey);
        const encapsulated = kem.encaps(pubKey);
        
        // Use shared secret to derive AES key
        const aesKey = await crypto.subtle.importKey(
          'raw',
          encapsulated.sharedSecret,
          { name: 'AES-GCM' },
          false,
          ['encrypt']
        );
        
        const enc = new TextEncoder();
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const encrypted = await crypto.subtle.encrypt(
          { name: 'AES-GCM', iv: iv },
          aesKey,
          enc.encode(data)
        );
        
        return {
          ciphertext: new Uint8Array(encrypted),
          encapsulatedKey: toB64(encapsulated.ciphertext),
          iv: iv
        };
      }

      static async decrypt(encryptedData, privateKey, variant = 'Kyber768') {
        if (!OQS_Module) {
          throw new Error('OQS library not initialized');
        }
        
        const kem = new OQS_Module.KEM(variant);
        const privKey = fromB64(privateKey);
        const encapsulatedKey = fromB64(encryptedData.encapsulatedKey);
        
        const sharedSecret = kem.decaps(encapsulatedKey, privKey);
        
        const aesKey = await crypto.subtle.importKey(
          'raw',
          sharedSecret,
          { name: 'AES-GCM' },
          false,
          ['decrypt']
        );
        
        const decrypted = await crypto.subtle.decrypt(
          { name: 'AES-GCM', iv: encryptedData.iv },
          aesKey,
          encryptedData.ciphertext
        );
        
        return new TextDecoder().decode(decrypted);
      }
    }

    // Dilithium Implementation (using OQS library)
    class DilithiumSignature {
      static async generateKeyPair(variant = 'Dilithium3') {
        if (!OQS_Module) {
          throw new Error('OQS library not initialized');
        }
        
        const sig = new OQS_Module.Signature(variant);
        const keypair = sig.keypair();
        
        return {
          publicKey: toB64(keypair.publicKey),
          privateKey: toB64(keypair.secretKey),
          variant: variant
        };
      }

      static async sign(data, privateKey, variant = 'Dilithium3') {
        if (!OQS_Module) {
          throw new Error('OQS library not initialized');
        }
        
        const sig = new OQS_Module.Signature(variant);
        const privKey = fromB64(privateKey);
        const enc = new TextEncoder();
        const signature = sig.sign(enc.encode(data), privKey);
        
        return toB64(signature);
      }

      static async verify(data, signature, publicKey, variant = 'Dilithium3') {
        if (!OQS_Module) {
          throw new Error('OQS library not initialized');
        }
        
        const sig = new OQS_Module.Signature(variant);
        const pubKey = fromB64(publicKey);
        const sigData = fromB64(signature);
        const enc = new TextEncoder();
        
        return sig.verify(enc.encode(data), sigData, pubKey);
      }
    }

    // Falcon Implementation (using OQS library)
    class FalconSignature {
      static async generateKeyPair(variant = 'Falcon512') {
        if (!OQS_Module) {
          throw new Error('OQS library not initialized');
        }
        
        const sig = new OQS_Module.Signature(variant);
        const keypair = sig.keypair();
        
        return {
          publicKey: toB64(keypair.publicKey),
          privateKey: toB64(keypair.secretKey),
          variant: variant
        };
      }

      static async sign(data, privateKey, variant = 'Falcon512') {
        if (!OQS_Module) {
          throw new Error('OQS library not initialized');
        }
        
        const sig = new OQS_Module.Signature(variant);
        const privKey = fromB64(privateKey);
        const enc = new TextEncoder();
        const signature = sig.sign(enc.encode(data), privKey);
        
        return toB64(signature);
      }

      static async verify(data, signature, publicKey, variant = 'Falcon512') {
        if (!OQS_Module) {
          throw new Error('OQS library not initialized');
        }
        
        const sig = new OQS_Module.Signature(variant);
        const pubKey = fromB64(publicKey);
        const sigData = fromB64(signature);
        const enc = new TextEncoder();
        
        return sig.verify(enc.encode(data), sigData, pubKey);
      }
    }

    // SPHINCS+ Implementation (using OQS library)
    class SPHINCSPlusSignature {
      static async generateKeyPair(variant = 'SPHINCS+-SHA256-128f-simple') {
        if (!OQS_Module) {
          throw new Error('OQS library not initialized');
        }
        
        const sig = new OQS_Module.Signature(variant);
        const keypair = sig.keypair();
        
        return {
          publicKey: toB64(keypair.publicKey),
          privateKey: toB64(keypair.secretKey),
          variant: variant
        };
      }

      static async sign(data, privateKey, variant = 'SPHINCS+-SHA256-128f-simple') {
        if (!OQS_Module) {
          throw new Error('OQS library not initialized');
        }
        
        const sig = new OQS_Module.Signature(variant);
        const privKey = fromB64(privateKey);
        const enc = new TextEncoder();
        const signature = sig.sign(enc.encode(data), privKey);
        
        return toB64(signature);
      }

      static async verify(data, signature, publicKey, variant = 'SPHINCS+-SHA256-128f-simple') {
        if (!OQS_Module) {
          throw new Error('OQS library not initialized');
        }
        
        const sig = new OQS_Module.Signature(variant);
        const pubKey = fromB64(publicKey);
        const sigData = fromB64(signature);
        const enc = new TextEncoder();
        
        return sig.verify(enc.encode(data), sigData, pubKey);
      }
    }

    // Hybrid Encryption Implementation
    class HybridEncryption {
      static async encrypt(data, publicKey, keySize = 2048) {
        // Generate random AES key
        const aesKey = crypto.getRandomValues(new Uint8Array(32));
        
        // Encrypt AES key with RSA
        const rsaPublicKey = await RSAEncryption.importPublicKey(publicKey);
        const encryptedKey = await RSAEncryption.encrypt(toB64(aesKey), rsaPublicKey);
        
        // Encrypt data with AES
        const keyData = await crypto.subtle.importKey(
          'raw',
          aesKey,
          { name: 'AES-GCM' },
          false,
          ['encrypt']
        );
        
        const enc = new TextEncoder();
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const encrypted = await crypto.subtle.encrypt(
          { name: 'AES-GCM', iv: iv },
          keyData,
          enc.encode(data)
        );
        
        return {
          encryptedKey: new Uint8Array(encryptedKey),
          ciphertext: new Uint8Array(encrypted),
          iv: iv
        };
      }

      static async decrypt(encryptedData, privateKey) {
        // Decrypt AES key with RSA
        const rsaPrivateKey = await RSAEncryption.importPrivateKey(privateKey);
        const aesKeyData = await RSAEncryption.decrypt(encryptedData.encryptedKey, rsaPrivateKey);
        const aesKey = fromB64(aesKeyData);
        
        // Decrypt data with AES
        const keyData = await crypto.subtle.importKey(
          'raw',
          aesKey,
          { name: 'AES-GCM' },
          false,
          ['decrypt']
        );
        
        const decrypted = await crypto.subtle.decrypt(
          { name: 'AES-GCM', iv: encryptedData.iv },
          keyData,
          encryptedData.ciphertext
        );
        
        return new TextDecoder().decode(decrypted);
      }
    }

    // Steganography Implementation (LSB - Least Significant Bit)
    class Steganography {
      static async hideTextInImage(imageData, text) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        // Create image from data
        const img = new Image();
        img.src = imageData;
        
        return new Promise((resolve) => {
          img.onload = () => {
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Convert text to binary
            const textBinary = text.split('').map(char => char.charCodeAt(0).toString(2).padStart(8, '0')).join('');
            const lengthBinary = textBinary.length.toString(2).padStart(32, '0');
            const fullBinary = lengthBinary + textBinary;
            
            if (fullBinary.length > data.length / 4) {
              throw new Error('Text too long for this image');
            }
            
            // Hide text in LSB of red channel
            for (let i = 0; i < fullBinary.length; i++) {
              const pixelIndex = i * 4;
              data[pixelIndex] = (data[pixelIndex] & 0xFE) | parseInt(fullBinary[i]);
            }
            
            ctx.putImageData(imageData, 0, 0);
            const result = canvas.toDataURL('image/png');
            resolve(result);
          };
        });
      }

      static async extractTextFromImage(imageData) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        const img = new Image();
        img.src = imageData;
        
        return new Promise((resolve) => {
          img.onload = () => {
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Extract length (first 32 bits)
            let lengthBinary = '';
            for (let i = 0; i < 32; i++) {
              const pixelIndex = i * 4;
              lengthBinary += data[pixelIndex] & 1;
            }
            const length = parseInt(lengthBinary, 2);
            
            // Extract text
            let textBinary = '';
            for (let i = 32; i < 32 + length; i++) {
              const pixelIndex = i * 4;
              textBinary += data[pixelIndex] & 1;
            }
            
            // Convert binary to text
            const text = textBinary.match(/.{1,8}/g).map(byte => String.fromCharCode(parseInt(byte, 2))).join('');
            resolve(text);
          };
        });
      }
    }

    // Hashing Functions
    class HashFunctions {
      static async sha256(data) {
        const enc = new TextEncoder();
        const hash = await crypto.subtle.digest('SHA-256', enc.encode(data));
        return toB64(hash);
      }

      static async sha512(data) {
        const enc = new TextEncoder();
        const hash = await crypto.subtle.digest('SHA-512', enc.encode(data));
        return toB64(hash);
      }

      static async sha3_256(data) {
        const enc = new TextEncoder();
        const hash = await crypto.subtle.digest('SHA-3-256', enc.encode(data));
        return toB64(hash);
      }

      static async sha3_512(data) {
        const enc = new TextEncoder();
        const hash = await crypto.subtle.digest('SHA-3-512', enc.encode(data));
        return toB64(hash);
      }

      static async blake2b(data) {
        // Note: BLAKE2 not available in Web Crypto API, using SHA-256
        console.warn('BLAKE2 not available in Web Crypto API, using SHA-256');
        return await this.sha256(data);
      }

      static async blake3(data) {
        // Note: BLAKE3 not available in Web Crypto API, using SHA-256
        console.warn('BLAKE3 not available in Web Crypto API, using SHA-256');
        return await this.sha256(data);
      }
    }

    // Key Derivation Functions
    class KeyDerivationFunctions {
      static async argon2id(password, salt, iterations = 3, memory = 65536, parallelism = 4, keyLength = 32) {
        // Note: Argon2 not available in Web Crypto API, using PBKDF2
        console.warn('Argon2 not available in Web Crypto API, using PBKDF2');
        return await derive(password, salt, keyLength * 8);
      }

      static async pbkdf2(password, salt, iterations = 100000, keyLength = 32) {
        return await derive(password, salt, keyLength * 8);
      }

      static async scrypt(password, salt, N = 16384, r = 8, p = 1, keyLength = 32) {
        // Note: Scrypt not available in Web Crypto API, using PBKDF2
        console.warn('Scrypt not available in Web Crypto API, using PBKDF2');
        return await derive(password, salt, keyLength * 8);
      }
    }

    // File Shredding (Secure Delete) - Enhanced with Multiple Standards
    class FileShredding {
      // 1Ô∏è‚É£ 1-Pass Methods (Fast, SSD-Friendly)
      static async zeroFill(file) {
        const arrayBuffer = await file.arrayBuffer();
        const data = new Uint8Array(arrayBuffer);
        data.fill(0x00); // Overwrite with zeros
        return new Blob([data], { type: file.type });
      }

      static async randomFill(file) {
        const arrayBuffer = await file.arrayBuffer();
        const data = new Uint8Array(arrayBuffer);
        const randomData = crypto.getRandomValues(new Uint8Array(data.length));
        data.set(randomData);
        return new Blob([data], { type: file.type });
      }

      static async protectStar1Pass(file) {
        // Single-pass optimized random fill
        const arrayBuffer = await file.arrayBuffer();
        const data = new Uint8Array(arrayBuffer);
        const randomData = crypto.getRandomValues(new Uint8Array(data.length));
        data.set(randomData);
        return new Blob([data], { type: file.type });
      }

      // 2Ô∏è‚É£ 3-Pass Methods (Standard Secure)
      static async dod522022M(file) {
        const arrayBuffer = await file.arrayBuffer();
        const data = new Uint8Array(arrayBuffer);
        
        // Pass 1: 0x00
        data.fill(0x00);
        
        // Pass 2: 0xFF
        data.fill(0xFF);
        
        // Pass 3: Random data
        const randomData = crypto.getRandomValues(new Uint8Array(data.length));
        data.set(randomData);
        
        return new Blob([data], { type: file.type });
      }

      static async hmgIS5(file) {
        const arrayBuffer = await file.arrayBuffer();
        const data = new Uint8Array(arrayBuffer);
        
        // Pass 1: 0x00
        data.fill(0x00);
        
        // Pass 2: 0x01
        data.fill(0x01);
        
        // Pass 3: Random data
        const randomData = crypto.getRandomValues(new Uint8Array(data.length));
        data.set(randomData);
        
        return new Blob([data], { type: file.type });
      }

      static async navsoP523926(file) {
        const arrayBuffer = await file.arrayBuffer();
        const data = new Uint8Array(arrayBuffer);
        
        // Pass 1: Random
        const random1 = crypto.getRandomValues(new Uint8Array(data.length));
        data.set(random1);
        
        // Pass 2: Complement of 1st pass
        const complement = new Uint8Array(data.length);
        for (let i = 0; i < data.length; i++) {
          complement[i] = ~data[i];
        }
        data.set(complement);
        
        // Pass 3: Random
        const random2 = crypto.getRandomValues(new Uint8Array(data.length));
        data.set(random2);
        
        return new Blob([data], { type: file.type });
      }

      // 3Ô∏è‚É£ 7-Pass Methods (Extended Secure for HDDs)
      static async dod522022MExtended(file) {
        const arrayBuffer = await file.arrayBuffer();
        const data = new Uint8Array(arrayBuffer);
        
        // 7-pass pattern: 0/1/random sequence
        const patterns = [
          () => data.fill(0x00),           // Pass 1: 0x00
          () => data.fill(0xFF),           // Pass 2: 0xFF
          () => data.fill(0x00),           // Pass 3: 0x00
          () => data.fill(0xFF),           // Pass 4: 0xFF
          () => data.fill(0x00),           // Pass 5: 0x00
          () => data.fill(0xFF),           // Pass 6: 0xFF
          () => {                          // Pass 7: Random
            const randomData = crypto.getRandomValues(new Uint8Array(data.length));
            data.set(randomData);
          }
        ];
        
        for (const pattern of patterns) {
          pattern();
        }
        
        return new Blob([data], { type: file.type });
      }

      static async vsitr(file) {
        const arrayBuffer = await file.arrayBuffer();
        const data = new Uint8Array(arrayBuffer);
        
        // VSITR pattern: Alternating 0/1, final pass random
        for (let pass = 0; pass < 6; pass++) {
          if (pass % 2 === 0) {
            data.fill(0x00);
          } else {
            data.fill(0xFF);
          }
        }
        
        // Final pass: Random
        const randomData = crypto.getRandomValues(new Uint8Array(data.length));
        data.set(randomData);
        
        return new Blob([data], { type: file.type });
      }

      // 4Ô∏è‚É£ 35-Pass (Legacy Maximum for HDDs)
      static async gutmann(file) {
        const arrayBuffer = await file.arrayBuffer();
        const data = new Uint8Array(arrayBuffer);
        
        // Gutmann method: 4 random + 27 drive-specific + 4 random
        const patterns = [
          // 4 random passes
          () => { const r = crypto.getRandomValues(new Uint8Array(data.length)); data.set(r); },
          () => { const r = crypto.getRandomValues(new Uint8Array(data.length)); data.set(r); },
          () => { const r = crypto.getRandomValues(new Uint8Array(data.length)); data.set(r); },
          () => { const r = crypto.getRandomValues(new Uint8Array(data.length)); data.set(r); },
          
          // 27 drive-specific patterns (simplified for browser)
          ...Array(27).fill().map((_, i) => () => {
            const pattern = new Uint8Array(data.length);
            for (let j = 0; j < data.length; j++) {
              pattern[j] = (i * 0x55 + j * 0xAA) & 0xFF;
            }
            data.set(pattern);
          }),
          
          // 4 final random passes
          () => { const r = crypto.getRandomValues(new Uint8Array(data.length)); data.set(r); },
          () => { const r = crypto.getRandomValues(new Uint8Array(data.length)); data.set(r); },
          () => { const r = crypto.getRandomValues(new Uint8Array(data.length)); data.set(r); },
          () => { const r = crypto.getRandomValues(new Uint8Array(data.length)); data.set(r); }
        ];
        
        for (const pattern of patterns) {
          pattern();
        }
        
        return new Blob([data], { type: file.type });
      }

      // 5Ô∏è‚É£ 50-Pass Extreme (Overkill)
      static async protectStar50Pass(file) {
        const arrayBuffer = await file.arrayBuffer();
        const data = new Uint8Array(arrayBuffer);
        
        // 50 passes of random/pattern mix
        for (let pass = 0; pass < 50; pass++) {
          if (pass % 2 === 0) {
            // Random pass
            const randomData = crypto.getRandomValues(new Uint8Array(data.length));
            data.set(randomData);
          } else {
            // Pattern pass
            const pattern = new Uint8Array(data.length);
            for (let i = 0; i < data.length; i++) {
              pattern[i] = (pass * 0x33 + i * 0x77) & 0xFF;
            }
            data.set(pattern);
          }
        }
        
        return new Blob([data], { type: file.type });
      }

      static async custom50Pass(file, customPatterns = []) {
        const arrayBuffer = await file.arrayBuffer();
        const data = new Uint8Array(arrayBuffer);
        
        // 50 passes with custom patterns or random
        for (let pass = 0; pass < 50; pass++) {
          if (customPatterns[pass]) {
            data.set(customPatterns[pass]);
          } else {
            const randomData = crypto.getRandomValues(new Uint8Array(data.length));
            data.set(randomData);
          }
        }
        
        return new Blob([data], { type: file.type });
      }

      // 6Ô∏è‚É£ Cryptographic / Logical Wipe
      static async cryptographicErase(file) {
        const arrayBuffer = await file.arrayBuffer();
        const data = new Uint8Array(arrayBuffer);
        
        // Encrypt with random AES key
        const randomKey = crypto.getRandomValues(new Uint8Array(32));
        const iv = crypto.getRandomValues(new Uint8Array(12));
        
        // Import key for AES-GCM
        const aesKey = await crypto.subtle.importKey(
          'raw',
          randomKey,
          { name: 'AES-GCM' },
          false,
          ['encrypt']
        );
        
        // Encrypt the data
        const encrypted = await crypto.subtle.encrypt(
          { name: 'AES-GCM', iv: iv },
          aesKey,
          data
        );
        
        // Overwrite with encrypted version
        const encryptedArray = new Uint8Array(encrypted);
        data.set(encryptedArray);
        
        // Key is now "forgotten" (not stored anywhere)
        return new Blob([data], { type: file.type });
      }

      // Legacy method for backward compatibility
      static async secureDelete(file, passes = 35) {
        console.warn('Using legacy secureDelete method. Consider using specific methods like gutmann() or cryptographicErase().');
        return await this.gutmann(file);
      }

      // Utility method to get method information
      static getMethodInfo() {
        return {
          'zero-fill': {
            name: 'Zero Fill (1-pass)',
            description: 'Fast, SSD-friendly - overwrite with zeros once',
            passes: 1,
            speed: 'Fast',
            security: 'Basic',
            browserCompatible: true
          },
          'random-fill': {
            name: 'Random Fill (1-pass)',
            description: 'Fast, SSD-friendly - overwrite with random data once',
            passes: 1,
            speed: 'Fast',
            security: 'Good',
            browserCompatible: true
          },
          'protectstar-1pass': {
            name: 'ProtectStar 1-pass',
            description: 'Single-pass optimized random fill',
            passes: 1,
            speed: 'Fast',
            security: 'Good',
            browserCompatible: true
          },
          'dod-522022m': {
            name: 'DoD 5220.22-M (3-pass)',
            description: 'US Department of Defense standard - 0x00, 0xFF, Random',
            passes: 3,
            speed: 'Medium',
            security: 'High',
            browserCompatible: true
          },
          'hmg-is5': {
            name: 'HMG IS5 / NCSC-TG-025 (3-pass)',
            description: 'UK Government standard - 0, 1, Random',
            passes: 3,
            speed: 'Medium',
            security: 'High',
            browserCompatible: true
          },
          'navso-p523926': {
            name: 'NAVSO P-5239-26 (3-pass)',
            description: 'US Navy standard - Random, Complement, Random',
            passes: 3,
            speed: 'Medium',
            security: 'High',
            browserCompatible: true
          },
          'dod-extended': {
            name: 'DoD 5220.22-M Extended (7-pass)',
            description: 'Extended DoD standard for HDDs - 0/1/random pattern sequence',
            passes: 7,
            speed: 'Slow',
            security: 'Very High',
            browserCompatible: true
          },
          'vsitr': {
            name: 'VSITR (7-pass)',
            description: 'German standard - alternating 0/1, final pass random',
            passes: 7,
            speed: 'Slow',
            security: 'Very High',
            browserCompatible: true
          },
          'gutmann': {
            name: 'Gutmann (35-pass)',
            description: 'Legacy maximum for HDDs - 4 random + 27 patterns + 4 random',
            passes: 35,
            speed: 'Very Slow',
            security: 'Maximum',
            browserCompatible: true
          },
          'protectstar-50': {
            name: 'ProtectStar 50-pass',
            description: 'Proprietary random/pattern mix - extreme overwrite',
            passes: 50,
            speed: 'Extremely Slow',
            security: 'Overkill',
            browserCompatible: true
          },
          'cryptographic-erase': {
            name: 'Cryptographic Erase',
            description: 'Encrypt then delete key - fastest and most effective',
            passes: 1,
            speed: 'Very Fast',
            security: 'Maximum',
            browserCompatible: true
          }
        };
      }
    }

    // UI Event Handlers and Functions
    
    // Method Selection
    function setupMethodSelection() {
      const methodButtons = document.querySelectorAll('.method-btn');
      methodButtons.forEach(button => {
        button.addEventListener('click', () => {
          const method = button.dataset.method;
          selectedMethod = method;
          
          // Hide all tab groups
          document.querySelectorAll('.tabs').forEach(tab => tab.style.display = 'none');
          
          // Show operation selection for most methods
          const operationSelection = document.getElementById('operation-selection');
          if (method === 'security') {
            operationSelection.style.display = 'none';
            document.getElementById('security-tabs').style.display = 'flex';
          } else {
            operationSelection.style.display = 'block';
            operationSelection.style.display = 'flex';
          }
          
          // Update active button
          methodButtons.forEach(btn => btn.classList.remove('active'));
          button.classList.add('active');
        });
      });
    }

    // Operation Selection
    function setupOperationSelection() {
      const operationButtons = document.querySelectorAll('.operation-btn');
      operationButtons.forEach(button => {
        button.addEventListener('click', () => {
          const operation = button.dataset.operation;
          selectedOperation = operation;
          
          // Show appropriate tab group based on method and operation
          const tabGroupId = `${selectedMethod}-tabs`;
          const tabGroup = document.getElementById(tabGroupId);
          if (tabGroup) {
            tabGroup.style.display = 'flex';
            
            // Set initial active tab based on operation
            const tabButtons = tabGroup.querySelectorAll('.tab-button');
            tabButtons.forEach(tab => {
              if (tab.dataset.tab.includes(operation)) {
                tab.classList.add('active');
                showTab(tab.dataset.tab);
              } else {
                tab.classList.remove('active');
              }
            });
          }
          
          // Update active button
          operationButtons.forEach(btn => btn.classList.remove('active'));
          button.classList.add('active');
        });
      });
    }

    // Tab Switching
    function setupTabSwitching() {
      document.addEventListener('click', (e) => {
        if (e.target.classList.contains('tab-button')) {
          const tabId = e.target.dataset.tab;
          
          // Update active tab
          const tabGroup = e.target.closest('.tabs');
          tabGroup.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
          e.target.classList.add('active');
          
          showTab(tabId);
        }
      });
    }

    function showTab(tabId) {
      // Hide all tab content
      document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
      
      // Show selected tab
      const selectedTab = document.getElementById(tabId);
      if (selectedTab) {
        selectedTab.classList.add('active');
      }
    }

    // Status Display
    function showStatus(elementId, message, type) {
      const element = document.getElementById(elementId);
      if (element) {
        element.textContent = message;
        element.className = `status-indicator status-${type}`;
        element.style.display = 'block';
      }
    }

    // Copy to Clipboard
    function copyToClipboard(text, buttonId) {
      navigator.clipboard.writeText(text).then(() => {
        const button = document.getElementById(buttonId);
        if (button) {
          button.classList.add('copied');
          button.textContent = '‚úì Copied!';
          setTimeout(() => {
            button.classList.remove('copied');
            button.textContent = 'üìã Copy';
          }, 2000);
        }
      }).catch(err => {
        console.error('Failed to copy: ', err);
      });
    }

    // AES Encryption Functions
    async function encryptAES() {
      try {
        const plaintext = document.getElementById('aesPlaintext').value;
        const keySize = parseInt(document.getElementById('aesKeySize').value);
        const mode = document.getElementById('aesMode').value;
        const passphrase = document.getElementById('aesPassphrase').value;
        
        if (!plaintext || !passphrase) {
          showStatus('aesEncryptStatus', 'Please enter plaintext and passphrase', 'error');
          return;
        }
        
        showStatus('aesEncryptStatus', 'Encrypting...', 'loading');
        
        const salt = crypto.getRandomValues(new Uint8Array(16));
        const key = await derive(passphrase, salt, keySize);
        const result = await AESEncryption.encrypt(plaintext, key, mode);
        
        const output = {
          ciphertext: toB64(result.ciphertext),
          iv: toB64(result.iv),
          salt: toB64(salt),
          mode: result.mode
        };
        
        document.getElementById('aesCiphertext').value = JSON.stringify(output, null, 2);
        document.getElementById('aesCiphertextResult').style.display = 'block';
        showStatus('aesEncryptStatus', 'AES encryption successful!', 'success');
        
      } catch (error) {
        console.error('AES encryption error:', error);
        showStatus('aesEncryptStatus', `Encryption failed: ${error.message}`, 'error');
      }
    }

    async function decryptAES() {
      try {
        const ciphertextData = document.getElementById('aesDecCiphertext').value;
        const passphrase = document.getElementById('aesDecPassphrase').value;
        
        if (!ciphertextData || !passphrase) {
          showStatus('aesDecryptStatus', 'Please enter ciphertext and passphrase', 'error');
          return;
        }
        
        showStatus('aesDecryptStatus', 'Decrypting...', 'loading');
        
        const data = JSON.parse(ciphertextData);
        const salt = fromB64(data.salt);
        const key = await derive(passphrase, salt, 256);
        const plaintext = await AESEncryption.decrypt(fromB64(data.ciphertext), key, fromB64(data.iv), data.mode);
        
        document.getElementById('aesDecPlaintext').value = plaintext;
        document.getElementById('aesDecPlaintextResult').style.display = 'block';
        showStatus('aesDecryptStatus', 'AES decryption successful!', 'success');
        
      } catch (error) {
        console.error('AES decryption error:', error);
        showStatus('aesDecryptStatus', `Decryption failed: ${error.message}`, 'error');
      }
    }

    // ChaCha20 Functions
    async function encryptChaCha20() {
      try {
        const plaintext = document.getElementById('chachaPlaintext').value;
        const passphrase = document.getElementById('chachaPassphrase').value;
        
        if (!plaintext || !passphrase) {
          showStatus('chachaEncryptStatus', 'Please enter plaintext and passphrase', 'error');
          return;
        }
        
        showStatus('chachaEncryptStatus', 'Encrypting...', 'loading');
        
        const salt = crypto.getRandomValues(new Uint8Array(16));
        const key = await derive(passphrase, salt, 256);
        const result = await ChaCha20Encryption.encrypt(plaintext, key);
        
        const output = {
          ciphertext: toB64(result.ciphertext),
          nonce: toB64(result.nonce),
          salt: toB64(salt)
        };
        
        document.getElementById('chachaCiphertext').value = JSON.stringify(output, null, 2);
        document.getElementById('chachaCiphertextResult').style.display = 'block';
        showStatus('chachaEncryptStatus', 'ChaCha20 encryption successful!', 'success');
        
      } catch (error) {
        console.error('ChaCha20 encryption error:', error);
        showStatus('chachaEncryptStatus', `Encryption failed: ${error.message}`, 'error');
      }
    }

    async function decryptChaCha20() {
      try {
        const ciphertextData = document.getElementById('chachaDecCiphertext').value;
        const passphrase = document.getElementById('chachaDecPassphrase').value;
        
        if (!ciphertextData || !passphrase) {
          showStatus('chachaDecryptStatus', 'Please enter ciphertext and passphrase', 'error');
          return;
        }
        
        showStatus('chachaDecryptStatus', 'Decrypting...', 'loading');
        
        const data = JSON.parse(ciphertextData);
        const salt = fromB64(data.salt);
        const key = await derive(passphrase, salt, 256);
        const plaintext = await ChaCha20Encryption.decrypt(fromB64(data.ciphertext), key, fromB64(data.nonce));
        
        document.getElementById('chachaDecPlaintext').value = plaintext;
        document.getElementById('chachaDecPlaintextResult').style.display = 'block';
        showStatus('chachaDecryptStatus', 'ChaCha20 decryption successful!', 'success');
        
      } catch (error) {
        console.error('ChaCha20 decryption error:', error);
        showStatus('chachaDecryptStatus', `Decryption failed: ${error.message}`, 'error');
      }
    }

    // RSA Functions
    async function generateRSAKeys() {
      try {
        const keySize = parseInt(document.getElementById('rsaKeySize').value);
        showStatus('rsaKeyStatus', 'Generating RSA key pair...', 'loading');
        
        const keyPair = await RSAEncryption.generateKeyPair(keySize);
        const publicKey = await RSAEncryption.exportPublicKey(keyPair.publicKey);
        const privateKey = await RSAEncryption.exportPrivateKey(keyPair.privateKey);
        
        document.getElementById('rsaPublicKey').value = publicKey;
        document.getElementById('rsaPrivateKey').value = privateKey;
        document.getElementById('rsaKeyResult').style.display = 'block';
        showStatus('rsaKeyStatus', 'RSA key pair generated successfully!', 'success');
        
      } catch (error) {
        console.error('RSA key generation error:', error);
        showStatus('rsaKeyStatus', `Key generation failed: ${error.message}`, 'error');
      }
    }

    async function encryptRSA() {
      try {
        const plaintext = document.getElementById('rsaPlaintext').value;
        const publicKey = document.getElementById('rsaEncPublicKey').value;
        
        if (!plaintext || !publicKey) {
          showStatus('rsaEncryptStatus', 'Please enter plaintext and public key', 'error');
          return;
        }
        
        showStatus('rsaEncryptStatus', 'Encrypting...', 'loading');
        
        const importedPublicKey = await RSAEncryption.importPublicKey(publicKey);
        const ciphertext = await RSAEncryption.encrypt(plaintext, importedPublicKey);
        
        document.getElementById('rsaCiphertext').value = toB64(ciphertext);
        document.getElementById('rsaCiphertextResult').style.display = 'block';
        showStatus('rsaEncryptStatus', 'RSA encryption successful!', 'success');
        
      } catch (error) {
        console.error('RSA encryption error:', error);
        showStatus('rsaEncryptStatus', `Encryption failed: ${error.message}`, 'error');
      }
    }

    async function decryptRSA() {
      try {
        const ciphertext = document.getElementById('rsaDecCiphertext').value;
        const privateKey = document.getElementById('rsaDecPrivateKey').value;
        
        if (!ciphertext || !privateKey) {
          showStatus('rsaDecryptStatus', 'Please enter ciphertext and private key', 'error');
          return;
        }
        
        showStatus('rsaDecryptStatus', 'Decrypting...', 'loading');
        
        const importedPrivateKey = await RSAEncryption.importPrivateKey(privateKey);
        const plaintext = await RSAEncryption.decrypt(fromB64(ciphertext), importedPrivateKey);
        
        document.getElementById('rsaDecPlaintext').value = plaintext;
        document.getElementById('rsaDecPlaintextResult').style.display = 'block';
        showStatus('rsaDecryptStatus', 'RSA decryption successful!', 'success');
        
      } catch (error) {
        console.error('RSA decryption error:', error);
        showStatus('rsaDecryptStatus', `Decryption failed: ${error.message}`, 'error');
      }
    }

    // Kyber Functions
    async function generateKyberKeys() {
      try {
        const variant = document.getElementById('kyberVariant').value;
        showStatus('kyberKeyStatus', 'Generating Kyber key pair...', 'loading');
        
        const keyPair = await KyberEncryption.generateKeyPair(variant);
        
        document.getElementById('kyberPublicKey').value = keyPair.publicKey;
        document.getElementById('kyberPrivateKey').value = keyPair.privateKey;
        document.getElementById('kyberKeyResult').style.display = 'block';
        showStatus('kyberKeyStatus', 'Kyber key pair generated successfully!', 'success');
        
      } catch (error) {
        console.error('Kyber key generation error:', error);
        showStatus('kyberKeyStatus', `Key generation failed: ${error.message}`, 'error');
      }
    }

    async function encryptKyber() {
      try {
        const plaintext = document.getElementById('kyberPlaintext').value;
        const publicKey = document.getElementById('kyberEncPublicKey').value;
        const variant = document.getElementById('kyberEncVariant').value;
        
        if (!plaintext || !publicKey) {
          showStatus('kyberEncryptStatus', 'Please enter plaintext and public key', 'error');
          return;
        }
        
        showStatus('kyberEncryptStatus', 'Encrypting...', 'loading');
        
        const result = await KyberEncryption.encrypt(plaintext, publicKey, variant);
        
        const output = {
          ciphertext: toB64(result.ciphertext),
          encapsulatedKey: result.encapsulatedKey,
          iv: toB64(result.iv)
        };
        
        document.getElementById('kyberCiphertext').value = JSON.stringify(output, null, 2);
        document.getElementById('kyberCiphertextResult').style.display = 'block';
        showStatus('kyberEncryptStatus', 'Kyber encryption successful!', 'success');
        
      } catch (error) {
        console.error('Kyber encryption error:', error);
        showStatus('kyberEncryptStatus', `Encryption failed: ${error.message}`, 'error');
      }
    }

    async function decryptKyber() {
      try {
        const ciphertextData = document.getElementById('kyberDecCiphertext').value;
        const privateKey = document.getElementById('kyberDecPrivateKey').value;
        const variant = document.getElementById('kyberDecVariant').value;
        
        if (!ciphertextData || !privateKey) {
          showStatus('kyberDecryptStatus', 'Please enter ciphertext and private key', 'error');
          return;
        }
        
        showStatus('kyberDecryptStatus', 'Decrypting...', 'loading');
        
        const data = JSON.parse(ciphertextData);
        const encryptedData = {
          ciphertext: fromB64(data.ciphertext),
          encapsulatedKey: data.encapsulatedKey,
          iv: fromB64(data.iv)
        };
        
        const plaintext = await KyberEncryption.decrypt(encryptedData, privateKey, variant);
        
        document.getElementById('kyberDecPlaintext').value = plaintext;
        document.getElementById('kyberDecPlaintextResult').style.display = 'block';
        showStatus('kyberDecryptStatus', 'Kyber decryption successful!', 'success');
        
      } catch (error) {
        console.error('Kyber decryption error:', error);
        showStatus('kyberDecryptStatus', `Decryption failed: ${error.message}`, 'error');
      }
    }

    // Steganography Functions
    async function hideDataInImage() {
      try {
        const fileInput = document.getElementById('stegoImageFile');
        const textInput = document.getElementById('stegoText');
        
        if (!fileInput.files[0] || !textInput.value) {
          showStatus('stegoEncryptStatus', 'Please select an image and enter text to hide', 'error');
          return;
        }
        
        showStatus('stegoEncryptStatus', 'Hiding data in image...', 'loading');
        
        const file = fileInput.files[0];
        const imageData = URL.createObjectURL(file);
        const text = textInput.value;
        
        const result = await Steganography.hideTextInImage(imageData, text);
        
        const link = document.getElementById('downloadStegoImage');
        link.href = result;
        link.download = 'stego_image.png';
        link.style.display = 'block';
        
        showStatus('stegoEncryptStatus', 'Data hidden successfully!', 'success');
        
      } catch (error) {
        console.error('Steganography error:', error);
        showStatus('stegoEncryptStatus', `Failed to hide data: ${error.message}`, 'error');
      }
    }

    async function extractDataFromImage() {
      try {
        const fileInput = document.getElementById('stegoExtractImageFile');
        
        if (!fileInput.files[0]) {
          showStatus('stegoDecryptStatus', 'Please select an image to extract data from', 'error');
          return;
        }
        
        showStatus('stegoDecryptStatus', 'Extracting data from image...', 'loading');
        
        const file = fileInput.files[0];
        const imageData = URL.createObjectURL(file);
        
        const text = await Steganography.extractTextFromImage(imageData);
        
        document.getElementById('stegoExtractedText').value = text;
        document.getElementById('stegoExtractedTextResult').style.display = 'block';
        showStatus('stegoDecryptStatus', 'Data extracted successfully!', 'success');
        
      } catch (error) {
        console.error('Steganography extraction error:', error);
        showStatus('stegoDecryptStatus', `Failed to extract data: ${error.message}`, 'error');
      }
    }

    // Hashing Functions
    async function hashData() {
      try {
        const data = document.getElementById('hashInput').value;
        const algorithm = document.getElementById('hashAlgorithm').value;
        
        if (!data) {
          showStatus('hashStatus', 'Please enter data to hash', 'error');
          return;
        }
        
        showStatus('hashStatus', 'Computing hash...', 'loading');
        
        let hash;
        switch (algorithm) {
          case 'sha256':
            hash = await HashFunctions.sha256(data);
            break;
          case 'sha512':
            hash = await HashFunctions.sha512(data);
            break;
          case 'sha3_256':
            hash = await HashFunctions.sha3_256(data);
            break;
          case 'sha3_512':
            hash = await HashFunctions.sha3_512(data);
            break;
          case 'blake2b':
            hash = await HashFunctions.blake2b(data);
            break;
          case 'blake3':
            hash = await HashFunctions.blake3(data);
            break;
          default:
            hash = await HashFunctions.sha256(data);
        }
        
        document.getElementById('hashResult').value = hash;
        document.getElementById('hashResultDisplay').style.display = 'block';
        showStatus('hashStatus', 'Hash computed successfully!', 'success');
        
      } catch (error) {
        console.error('Hashing error:', error);
        showStatus('hashStatus', `Hashing failed: ${error.message}`, 'error');
      }
    }

    // Key Derivation Functions
    async function deriveKey() {
      try {
        const password = document.getElementById('kdfPassword').value;
        const salt = document.getElementById('kdfSalt').value || toB64(crypto.getRandomValues(new Uint8Array(16)));
        const algorithm = document.getElementById('kdfAlgorithm').value;
        
        if (!password) {
          showStatus('kdfStatus', 'Please enter a password', 'error');
          return;
        }
        
        showStatus('kdfStatus', 'Deriving key...', 'loading');
        
        let derivedKey;
        switch (algorithm) {
          case 'argon2id':
            derivedKey = await KeyDerivationFunctions.argon2id(password, fromB64(salt));
            break;
          case 'pbkdf2':
            derivedKey = await KeyDerivationFunctions.pbkdf2(password, fromB64(salt));
            break;
          case 'scrypt':
            derivedKey = await KeyDerivationFunctions.scrypt(password, fromB64(salt));
            break;
          default:
            derivedKey = await KeyDerivationFunctions.pbkdf2(password, fromB64(salt));
        }
        
        document.getElementById('kdfResult').value = toB64(derivedKey);
        document.getElementById('kdfSalt').value = salt;
        document.getElementById('kdfResultDisplay').style.display = 'block';
        showStatus('kdfStatus', 'Key derived successfully!', 'success');
        
      } catch (error) {
        console.error('Key derivation error:', error);
        showStatus('kdfStatus', `Key derivation failed: ${error.message}`, 'error');
      }
    }

    // File Shredding - Enhanced with Multiple Standards
    async function shredFile() {
      try {
        const fileInput = document.getElementById('shredFileInput');
        const method = document.getElementById('shredMethod').value;
        
        if (!fileInput.files[0]) {
          showStatus('shredStatus', 'Please select a file to shred', 'error');
          return;
        }
        
        const file = fileInput.files[0];
        const methodInfo = FileShredding.getMethodInfo()[method];
        
        showStatus('shredStatus', `Shredding file using ${methodInfo.name}...`, 'loading');
        
        let shreddedFile;
        switch (method) {
          case 'zero-fill':
            shreddedFile = await FileShredding.zeroFill(file);
            break;
          case 'random-fill':
            shreddedFile = await FileShredding.randomFill(file);
            break;
          case 'protectstar-1pass':
            shreddedFile = await FileShredding.protectStar1Pass(file);
            break;
          case 'dod-522022m':
            shreddedFile = await FileShredding.dod522022M(file);
            break;
          case 'hmg-is5':
            shreddedFile = await FileShredding.hmgIS5(file);
            break;
          case 'navso-p523926':
            shreddedFile = await FileShredding.navsoP523926(file);
            break;
          case 'dod-extended':
            shreddedFile = await FileShredding.dod522022MExtended(file);
            break;
          case 'vsitr':
            shreddedFile = await FileShredding.vsitr(file);
            break;
          case 'gutmann':
            shreddedFile = await FileShredding.gutmann(file);
            break;
          case 'protectstar-50':
            shreddedFile = await FileShredding.protectStar50Pass(file);
            break;
          case 'cryptographic-erase':
            shreddedFile = await FileShredding.cryptographicErase(file);
            break;
          default:
            throw new Error('Unknown shredding method');
        }
        
        const link = document.getElementById('downloadShreddedFile');
        link.href = URL.createObjectURL(shreddedFile);
        link.download = `shredded_${method}_${file.name}`;
        link.style.display = 'block';
        
        showStatus('shredStatus', `File shredded successfully using ${methodInfo.name}!`, 'success');
        
      } catch (error) {
        console.error('File shredding error:', error);
        showStatus('shredStatus', `File shredding failed: ${error.message}`, 'error');
      }
    }

    // Additional Security Functions
    
    // Method info display
    function updateMethodInfo() {
      const methodSelect = document.getElementById('shredMethod');
      const methodInfo = document.getElementById('methodInfo');
      const methodDetails = document.getElementById('methodDetails');
      
      if (methodSelect && methodInfo && methodDetails) {
        const selectedMethod = methodSelect.value;
        const info = FileShredding.getMethodInfo()[selectedMethod];
        
        if (info) {
          methodDetails.innerHTML = `
            <div class="method-details">
              <p><strong>Name:</strong> ${info.name}</p>
              <p><strong>Description:</strong> ${info.description}</p>
              <p><strong>Passes:</strong> ${info.passes}</p>
              <p><strong>Speed:</strong> ${info.speed}</p>
              <p><strong>Security Level:</strong> ${info.security}</p>
              <p><strong>Browser Compatible:</strong> ${info.browserCompatible ? '‚úÖ Yes' : '‚ùå No'}</p>
            </div>
          `;
          methodInfo.style.display = 'block';
        } else {
          methodInfo.style.display = 'none';
        }
      }
    }

    // Integrity check function
    async function checkIntegrity() {
      try {
        const originalFile = document.getElementById('integrityOriginal').files[0];
        const verifyFile = document.getElementById('integrityVerify').files[0];
        const algorithm = document.getElementById('integrityAlgorithm').value;
        
        if (!originalFile || !verifyFile) {
          showStatus('integrityStatus', 'Please select both files', 'error');
          return;
        }
        
        showStatus('integrityStatus', 'Checking integrity...', 'loading');
        
        // Read files
        const originalBuffer = await originalFile.arrayBuffer();
        const verifyBuffer = await verifyFile.arrayBuffer();
        
        // Convert to text for hashing
        const originalText = new TextDecoder().decode(originalBuffer);
        const verifyText = new TextDecoder().decode(verifyBuffer);
        
        // Hash both files
        let originalHash, verifyHash;
        switch (algorithm) {
          case 'sha256':
            originalHash = await HashFunctions.sha256(originalText);
            verifyHash = await HashFunctions.sha256(verifyText);
            break;
          case 'sha512':
            originalHash = await HashFunctions.sha512(originalText);
            verifyHash = await HashFunctions.sha512(verifyText);
            break;
          case 'sha3_256':
            originalHash = await HashFunctions.sha3_256(originalText);
            verifyHash = await HashFunctions.sha3_256(verifyText);
            break;
          default:
            originalHash = await HashFunctions.sha256(originalText);
            verifyHash = await HashFunctions.sha256(verifyText);
        }
        
        const isMatch = originalHash === verifyHash;
        
        const resultDiv = document.getElementById('integrityResult');
        const detailsDiv = document.getElementById('integrityDetails');
        
        detailsDiv.innerHTML = `
          <div class="integrity-result ${isMatch ? 'success' : 'error'}">
            <h5>${isMatch ? '‚úÖ Files Match' : '‚ùå Files Do Not Match'}</h5>
            <p><strong>Original File Hash (${algorithm.toUpperCase()}):</strong></p>
            <code>${originalHash}</code>
            <p><strong>Verify File Hash (${algorithm.toUpperCase()}):</strong></p>
            <code>${verifyHash}</code>
            <p><strong>Status:</strong> ${isMatch ? 'Integrity verified - files are identical' : 'Integrity check failed - files are different'}</p>
          </div>
        `;
        
        resultDiv.style.display = 'block';
        showStatus('integrityStatus', isMatch ? 'Integrity check passed!' : 'Integrity check failed!', isMatch ? 'success' : 'error');
        
      } catch (error) {
        console.error('Integrity check error:', error);
        showStatus('integrityStatus', `Integrity check failed: ${error.message}`, 'error');
      }
    }

    // Initialize the application
    document.addEventListener('DOMContentLoaded', function() {
      setupMethodSelection();
      setupOperationSelection();
      setupTabSwitching();
      initializeOQS();
      
      // Add event listeners for new features
      const shredMethodSelect = document.getElementById('shredMethod');
      if (shredMethodSelect) {
        shredMethodSelect.addEventListener('change', updateMethodInfo);
        // Initialize method info
        updateMethodInfo();
      }
      
      console.log('Advanced Encryption Tool initialized with real cryptographic algorithms');
    });
  </script>
  
  <!-- Security Enhancement -->
  <script src="security-enhancement.js"></script>
</body>
</html>